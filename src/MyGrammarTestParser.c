/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : MyGrammarTest.g
 *     -                            On : 2024-10-09 23:59:32
 *     -                for the parser : MyGrammarTestParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "MyGrammarTestParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pMyGrammarTestParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pMyGrammarTestParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pMyGrammarTestParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pMyGrammarTestParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   MyGrammarTestParserTokenNames[48+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "BITS_LITERAL",
        (pANTLR3_UINT8) "BOOL_LITERAL",
        (pANTLR3_UINT8) "CHAR",
        (pANTLR3_UINT8) "DEC_LITERAL",
        (pANTLR3_UINT8) "ESC_SEQ",
        (pANTLR3_UINT8) "HEX_DIGIT",
        (pANTLR3_UINT8) "HEX_LITERAL",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "LINE_COMMENT",
        (pANTLR3_UINT8) "STRING_LIT",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "'!'",
        (pANTLR3_UINT8) "'%'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "'+='",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'/'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "':='",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'array'",
        (pANTLR3_UINT8) "'begin'",
        (pANTLR3_UINT8) "'bool'",
        (pANTLR3_UINT8) "'break'",
        (pANTLR3_UINT8) "'byte'",
        (pANTLR3_UINT8) "'char'",
        (pANTLR3_UINT8) "'do'",
        (pANTLR3_UINT8) "'else'",
        (pANTLR3_UINT8) "'end'",
        (pANTLR3_UINT8) "'if'",
        (pANTLR3_UINT8) "'int'",
        (pANTLR3_UINT8) "'long'",
        (pANTLR3_UINT8) "'method'",
        (pANTLR3_UINT8) "'of'",
        (pANTLR3_UINT8) "'repeat'",
        (pANTLR3_UINT8) "'string'",
        (pANTLR3_UINT8) "'then'",
        (pANTLR3_UINT8) "'uint'",
        (pANTLR3_UINT8) "'ulong'",
        (pANTLR3_UINT8) "'until'",
        (pANTLR3_UINT8) "'var'",
        (pANTLR3_UINT8) "'while'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 MyGrammarTestParser_list_identifier_return
	list_identifier    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_list_item_return
	list_item    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_item_return
	item    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_source_return
	source    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_sourceItem_return
	sourceItem    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_funcDef_return
	funcDef    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_body_return
	body    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_typeRef_return
	typeRef    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_builtin_return
	builtin    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_custom_return
	custom    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_array_return
	array    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_funcSignature_return
	funcSignature    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_list_argDef_return
	list_argDef    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_argDef_return
	argDef    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_statement_return
	statement    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_ifStatement_return
	ifStatement    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_blockStatement_return
	blockStatement    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_whileStatement_return
	whileStatement    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_doStatement_return
	doStatement    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_breakStatement_return
	breakStatement    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_expressionStatement_return
	expressionStatement    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_expr_return
	expr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_assignExpr_return
	assignExpr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_binaryExpr_return
	binaryExpr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_additiveExpr_return
	additiveExpr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_multiplicativeExpr_return
	multiplicativeExpr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_unaryExpr_return
	unaryExpr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_primaryExpr_return
	primaryExpr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_call_return
	call    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_indexer_return
	indexer    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_literal_return
	literal    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_list_expr_return
	list_expr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_unOp_return
	unOp    (pMyGrammarTestParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred34_MyGrammarTest    (pMyGrammarTestParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred38_MyGrammarTest    (pMyGrammarTestParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred40_MyGrammarTest    (pMyGrammarTestParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred43_MyGrammarTest    (pMyGrammarTestParser ctx);
static void	MyGrammarTestParserFree(pMyGrammarTestParser ctx);
static void     MyGrammarTestParserReset (pMyGrammarTestParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "MyGrammarTest.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new MyGrammarTestParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pMyGrammarTestParser
MyGrammarTestParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return MyGrammarTestParserNewSSD(instream, NULL);
}

/** \brief Create a new MyGrammarTestParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pMyGrammarTestParser
MyGrammarTestParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pMyGrammarTestParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pMyGrammarTestParser) ANTLR3_CALLOC(1, sizeof(MyGrammarTestParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in MyGrammarTestParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our MyGrammarTestParser interface
     */
    ctx->list_identifier	= list_identifier;
    ctx->list_item	= list_item;
    ctx->item	= item;
    ctx->source	= source;
    ctx->sourceItem	= sourceItem;
    ctx->funcDef	= funcDef;
    ctx->body	= body;
    ctx->typeRef	= typeRef;
    ctx->builtin	= builtin;
    ctx->custom	= custom;
    ctx->array	= array;
    ctx->funcSignature	= funcSignature;
    ctx->list_argDef	= list_argDef;
    ctx->argDef	= argDef;
    ctx->statement	= statement;
    ctx->ifStatement	= ifStatement;
    ctx->blockStatement	= blockStatement;
    ctx->whileStatement	= whileStatement;
    ctx->doStatement	= doStatement;
    ctx->breakStatement	= breakStatement;
    ctx->expressionStatement	= expressionStatement;
    ctx->expr	= expr;
    ctx->assignExpr	= assignExpr;
    ctx->binaryExpr	= binaryExpr;
    ctx->additiveExpr	= additiveExpr;
    ctx->multiplicativeExpr	= multiplicativeExpr;
    ctx->unaryExpr	= unaryExpr;
    ctx->primaryExpr	= primaryExpr;
    ctx->call	= call;
    ctx->indexer	= indexer;
    ctx->literal	= literal;
    ctx->list_expr	= list_expr;
    ctx->unOp	= unOp;
    ctx->synpred34_MyGrammarTest	= synpred34_MyGrammarTest;
    ctx->synpred38_MyGrammarTest	= synpred38_MyGrammarTest;
    ctx->synpred40_MyGrammarTest	= synpred40_MyGrammarTest;
    ctx->synpred43_MyGrammarTest	= synpred43_MyGrammarTest;
    ctx->free			= MyGrammarTestParserFree;
    ctx->reset			= MyGrammarTestParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */
ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);

ctx->vectors	= antlr3VectorFactoryNew(0);
    /* Install the token table
     */
    PSRSTATE->tokenNames   = MyGrammarTestParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
MyGrammarTestParserReset (pMyGrammarTestParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 MyGrammarTestParserFree(pMyGrammarTestParser ctx)
 {
    /* Free any scope memory
     */

ctx->vectors->close(ctx->vectors);
/* We created the adaptor so we must free it
 */
ADAPTOR->free(ADAPTOR);
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return MyGrammarTestParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_list_identifier298  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_list_identifier298_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_list_identifier298	= { FOLLOW_IDENTIFIER_in_list_identifier298_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_list_identifier301  */
static	ANTLR3_BITWORD FOLLOW_22_in_list_identifier301_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_list_identifier301	= { FOLLOW_22_in_list_identifier301_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_list_identifier303  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_list_identifier303_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_list_identifier303	= { FOLLOW_IDENTIFIER_in_list_identifier303_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_item_in_list_item317  */
static	ANTLR3_BITWORD FOLLOW_item_in_list_item317_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_item_in_list_item317	= { FOLLOW_item_in_list_item317_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_list_item320  */
static	ANTLR3_BITWORD FOLLOW_22_in_list_item320_bits[]	= { ANTLR3_UINT64_LIT(0x00000000000024F0) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_list_item320	= { FOLLOW_22_in_list_item320_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_item_in_list_item322  */
static	ANTLR3_BITWORD FOLLOW_item_in_list_item322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_item_in_list_item322	= { FOLLOW_item_in_list_item322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sourceItem_in_source367  */
static	ANTLR3_BITWORD FOLLOW_sourceItem_in_source367_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sourceItem_in_source367	= { FOLLOW_sourceItem_in_source367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_funcDef_in_sourceItem377  */
static	ANTLR3_BITWORD FOLLOW_funcDef_in_sourceItem377_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_funcDef_in_sourceItem377	= { FOLLOW_funcDef_in_sourceItem377_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_funcDef387  */
static	ANTLR3_BITWORD FOLLOW_42_in_funcDef387_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_funcDef387	= { FOLLOW_42_in_funcDef387_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_funcSignature_in_funcDef389  */
static	ANTLR3_BITWORD FOLLOW_funcSignature_in_funcDef389_bits[]	= { ANTLR3_UINT64_LIT(0x0004000088000000) };
static  ANTLR3_BITSET_LIST FOLLOW_funcSignature_in_funcDef389	= { FOLLOW_funcSignature_in_funcDef389_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_body_in_funcDef393  */
static	ANTLR3_BITWORD FOLLOW_body_in_funcDef393_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_body_in_funcDef393	= { FOLLOW_body_in_funcDef393_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_funcDef397  */
static	ANTLR3_BITWORD FOLLOW_27_in_funcDef397_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_funcDef397	= { FOLLOW_27_in_funcDef397_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_50_in_body410  */
static	ANTLR3_BITWORD FOLLOW_50_in_body410_bits[]	= { ANTLR3_UINT64_LIT(0x000000008A000800) };
static  ANTLR3_BITSET_LIST FOLLOW_50_in_body410	= { FOLLOW_50_in_body410_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_identifier_in_body414  */
static	ANTLR3_BITWORD FOLLOW_list_identifier_in_body414_bits[]	= { ANTLR3_UINT64_LIT(0x000000000A000000) };
static  ANTLR3_BITSET_LIST FOLLOW_list_identifier_in_body414	= { FOLLOW_list_identifier_in_body414_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_25_in_body417  */
static	ANTLR3_BITWORD FOLLOW_25_in_body417_bits[]	= { ANTLR3_UINT64_LIT(0x0001A30D40000800) };
static  ANTLR3_BITSET_LIST FOLLOW_25_in_body417	= { FOLLOW_25_in_body417_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeRef_in_body419  */
static	ANTLR3_BITWORD FOLLOW_typeRef_in_body419_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_typeRef_in_body419	= { FOLLOW_typeRef_in_body419_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_body423  */
static	ANTLR3_BITWORD FOLLOW_27_in_body423_bits[]	= { ANTLR3_UINT64_LIT(0x000000008A000800) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_body423	= { FOLLOW_27_in_body423_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_blockStatement_in_body431  */
static	ANTLR3_BITWORD FOLLOW_blockStatement_in_body431_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_blockStatement_in_body431	= { FOLLOW_blockStatement_in_body431_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_builtin_in_typeRef442  */
static	ANTLR3_BITWORD FOLLOW_builtin_in_typeRef442_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_builtin_in_typeRef442	= { FOLLOW_builtin_in_typeRef442_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_custom_in_typeRef446  */
static	ANTLR3_BITWORD FOLLOW_custom_in_typeRef446_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_custom_in_typeRef446	= { FOLLOW_custom_in_typeRef446_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_array_in_typeRef450  */
static	ANTLR3_BITWORD FOLLOW_array_in_typeRef450_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_array_in_typeRef450	= { FOLLOW_array_in_typeRef450_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_custom499  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_custom499_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_custom499	= { FOLLOW_IDENTIFIER_in_custom499_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_30_in_array509  */
static	ANTLR3_BITWORD FOLLOW_30_in_array509_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_30_in_array509	= { FOLLOW_30_in_array509_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_array511  */
static	ANTLR3_BITWORD FOLLOW_28_in_array511_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020400000) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_array511	= { FOLLOW_28_in_array511_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_array514  */
static	ANTLR3_BITWORD FOLLOW_22_in_array514_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020400000) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_array514	= { FOLLOW_22_in_array514_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_array518  */
static	ANTLR3_BITWORD FOLLOW_29_in_array518_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_array518	= { FOLLOW_29_in_array518_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_array520  */
static	ANTLR3_BITWORD FOLLOW_43_in_array520_bits[]	= { ANTLR3_UINT64_LIT(0x0001A30D40000800) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_array520	= { FOLLOW_43_in_array520_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeRef_in_array522  */
static	ANTLR3_BITWORD FOLLOW_typeRef_in_array522_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typeRef_in_array522	= { FOLLOW_typeRef_in_array522_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_funcSignature530  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_funcSignature530_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_funcSignature530	= { FOLLOW_IDENTIFIER_in_funcSignature530_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_17_in_funcSignature532  */
static	ANTLR3_BITWORD FOLLOW_17_in_funcSignature532_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040800) };
static  ANTLR3_BITSET_LIST FOLLOW_17_in_funcSignature532	= { FOLLOW_17_in_funcSignature532_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_argDef_in_funcSignature534  */
static	ANTLR3_BITWORD FOLLOW_list_argDef_in_funcSignature534_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_list_argDef_in_funcSignature534	= { FOLLOW_list_argDef_in_funcSignature534_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_funcSignature536  */
static	ANTLR3_BITWORD FOLLOW_18_in_funcSignature536_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_funcSignature536	= { FOLLOW_18_in_funcSignature536_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_25_in_funcSignature539  */
static	ANTLR3_BITWORD FOLLOW_25_in_funcSignature539_bits[]	= { ANTLR3_UINT64_LIT(0x0001A30D40000800) };
static  ANTLR3_BITSET_LIST FOLLOW_25_in_funcSignature539	= { FOLLOW_25_in_funcSignature539_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeRef_in_funcSignature541  */
static	ANTLR3_BITWORD FOLLOW_typeRef_in_funcSignature541_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typeRef_in_funcSignature541	= { FOLLOW_typeRef_in_funcSignature541_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argDef_in_list_argDef559  */
static	ANTLR3_BITWORD FOLLOW_argDef_in_list_argDef559_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_argDef_in_list_argDef559	= { FOLLOW_argDef_in_list_argDef559_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_list_argDef562  */
static	ANTLR3_BITWORD FOLLOW_22_in_list_argDef562_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_list_argDef562	= { FOLLOW_22_in_list_argDef562_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argDef_in_list_argDef564  */
static	ANTLR3_BITWORD FOLLOW_argDef_in_list_argDef564_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_argDef_in_list_argDef564	= { FOLLOW_argDef_in_list_argDef564_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_argDef584  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_argDef584_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_argDef584	= { FOLLOW_IDENTIFIER_in_argDef584_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_25_in_argDef587  */
static	ANTLR3_BITWORD FOLLOW_25_in_argDef587_bits[]	= { ANTLR3_UINT64_LIT(0x0001A30D40000800) };
static  ANTLR3_BITSET_LIST FOLLOW_25_in_argDef587	= { FOLLOW_25_in_argDef587_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeRef_in_argDef589  */
static	ANTLR3_BITWORD FOLLOW_typeRef_in_argDef589_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typeRef_in_argDef589	= { FOLLOW_typeRef_in_argDef589_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ifStatement_in_statement605  */
static	ANTLR3_BITWORD FOLLOW_ifStatement_in_statement605_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ifStatement_in_statement605	= { FOLLOW_ifStatement_in_statement605_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_blockStatement_in_statement609  */
static	ANTLR3_BITWORD FOLLOW_blockStatement_in_statement609_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_blockStatement_in_statement609	= { FOLLOW_blockStatement_in_statement609_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_whileStatement_in_statement613  */
static	ANTLR3_BITWORD FOLLOW_whileStatement_in_statement613_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_whileStatement_in_statement613	= { FOLLOW_whileStatement_in_statement613_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_doStatement_in_statement617  */
static	ANTLR3_BITWORD FOLLOW_doStatement_in_statement617_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_doStatement_in_statement617	= { FOLLOW_doStatement_in_statement617_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_breakStatement_in_statement625  */
static	ANTLR3_BITWORD FOLLOW_breakStatement_in_statement625_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_breakStatement_in_statement625	= { FOLLOW_breakStatement_in_statement625_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expressionStatement_in_statement629  */
static	ANTLR3_BITWORD FOLLOW_expressionStatement_in_statement629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expressionStatement_in_statement629	= { FOLLOW_expressionStatement_in_statement629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_ifStatement640  */
static	ANTLR3_BITWORD FOLLOW_39_in_ifStatement640_bits[]	= { ANTLR3_UINT64_LIT(0x000000000082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_ifStatement640	= { FOLLOW_39_in_ifStatement640_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_ifStatement642  */
static	ANTLR3_BITWORD FOLLOW_expr_in_ifStatement642_bits[]	= { ANTLR3_UINT64_LIT(0x0000400000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_ifStatement642	= { FOLLOW_expr_in_ifStatement642_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_46_in_ifStatement644  */
static	ANTLR3_BITWORD FOLLOW_46_in_ifStatement644_bits[]	= { ANTLR3_UINT64_LIT(0x000810828082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_46_in_ifStatement644	= { FOLLOW_46_in_ifStatement644_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_ifStatement646  */
static	ANTLR3_BITWORD FOLLOW_statement_in_ifStatement646_bits[]	= { ANTLR3_UINT64_LIT(0x0000002000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_ifStatement646	= { FOLLOW_statement_in_ifStatement646_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_ifStatement649  */
static	ANTLR3_BITWORD FOLLOW_37_in_ifStatement649_bits[]	= { ANTLR3_UINT64_LIT(0x000810828082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_ifStatement649	= { FOLLOW_37_in_ifStatement649_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_ifStatement651  */
static	ANTLR3_BITWORD FOLLOW_statement_in_ifStatement651_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_ifStatement651	= { FOLLOW_statement_in_ifStatement651_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_blockStatement662  */
static	ANTLR3_BITWORD FOLLOW_31_in_blockStatement662_bits[]	= { ANTLR3_UINT64_LIT(0x000810C28082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_blockStatement662	= { FOLLOW_31_in_blockStatement662_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_blockStatement664  */
static	ANTLR3_BITWORD FOLLOW_statement_in_blockStatement664_bits[]	= { ANTLR3_UINT64_LIT(0x000810C28082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_blockStatement664	= { FOLLOW_statement_in_blockStatement664_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_blockStatement667  */
static	ANTLR3_BITWORD FOLLOW_38_in_blockStatement667_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_blockStatement667	= { FOLLOW_38_in_blockStatement667_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_blockStatement669  */
static	ANTLR3_BITWORD FOLLOW_27_in_blockStatement669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_blockStatement669	= { FOLLOW_27_in_blockStatement669_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_51_in_whileStatement678  */
static	ANTLR3_BITWORD FOLLOW_51_in_whileStatement678_bits[]	= { ANTLR3_UINT64_LIT(0x000000000082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_51_in_whileStatement678	= { FOLLOW_51_in_whileStatement678_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_whileStatement680  */
static	ANTLR3_BITWORD FOLLOW_expr_in_whileStatement680_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_whileStatement680	= { FOLLOW_expr_in_whileStatement680_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_whileStatement682  */
static	ANTLR3_BITWORD FOLLOW_36_in_whileStatement682_bits[]	= { ANTLR3_UINT64_LIT(0x000810828082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_whileStatement682	= { FOLLOW_36_in_whileStatement682_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_whileStatement684  */
static	ANTLR3_BITWORD FOLLOW_statement_in_whileStatement684_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_whileStatement684	= { FOLLOW_statement_in_whileStatement684_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_doStatement693  */
static	ANTLR3_BITWORD FOLLOW_44_in_doStatement693_bits[]	= { ANTLR3_UINT64_LIT(0x000810828082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_44_in_doStatement693	= { FOLLOW_44_in_doStatement693_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_doStatement695  */
static	ANTLR3_BITWORD FOLLOW_statement_in_doStatement695_bits[]	= { ANTLR3_UINT64_LIT(0x000A000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_doStatement695	= { FOLLOW_statement_in_doStatement695_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_doStatement697  */
static	ANTLR3_BITWORD FOLLOW_set_in_doStatement697_bits[]	= { ANTLR3_UINT64_LIT(0x000000000082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_doStatement697	= { FOLLOW_set_in_doStatement697_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_doStatement703  */
static	ANTLR3_BITWORD FOLLOW_expr_in_doStatement703_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_doStatement703	= { FOLLOW_expr_in_doStatement703_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_doStatement705  */
static	ANTLR3_BITWORD FOLLOW_27_in_doStatement705_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_doStatement705	= { FOLLOW_27_in_doStatement705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_breakStatement714  */
static	ANTLR3_BITWORD FOLLOW_33_in_breakStatement714_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_breakStatement714	= { FOLLOW_33_in_breakStatement714_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_breakStatement716  */
static	ANTLR3_BITWORD FOLLOW_27_in_breakStatement716_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_breakStatement716	= { FOLLOW_27_in_breakStatement716_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expressionStatement725  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expressionStatement725_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expressionStatement725	= { FOLLOW_expr_in_expressionStatement725_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_expressionStatement727  */
static	ANTLR3_BITWORD FOLLOW_27_in_expressionStatement727_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_expressionStatement727	= { FOLLOW_27_in_expressionStatement727_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignExpr_in_expr740  */
static	ANTLR3_BITWORD FOLLOW_assignExpr_in_expr740_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignExpr_in_expr740	= { FOLLOW_assignExpr_in_expr740_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryExpr_in_assignExpr751  */
static	ANTLR3_BITWORD FOLLOW_binaryExpr_in_assignExpr751_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004200000) };
static  ANTLR3_BITSET_LIST FOLLOW_binaryExpr_in_assignExpr751	= { FOLLOW_binaryExpr_in_assignExpr751_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_assignExpr753  */
static	ANTLR3_BITWORD FOLLOW_set_in_assignExpr753_bits[]	= { ANTLR3_UINT64_LIT(0x000000000082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_assignExpr753	= { FOLLOW_set_in_assignExpr753_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryExpr_in_assignExpr761  */
static	ANTLR3_BITWORD FOLLOW_binaryExpr_in_assignExpr761_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_binaryExpr_in_assignExpr761	= { FOLLOW_binaryExpr_in_assignExpr761_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryExpr_in_assignExpr766  */
static	ANTLR3_BITWORD FOLLOW_binaryExpr_in_assignExpr766_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_binaryExpr_in_assignExpr766	= { FOLLOW_binaryExpr_in_assignExpr766_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_additiveExpr_in_binaryExpr776  */
static	ANTLR3_BITWORD FOLLOW_additiveExpr_in_binaryExpr776_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_additiveExpr_in_binaryExpr776	= { FOLLOW_additiveExpr_in_binaryExpr776_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplicativeExpr_in_additiveExpr787  */
static	ANTLR3_BITWORD FOLLOW_multiplicativeExpr_in_additiveExpr787_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000900000) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplicativeExpr_in_additiveExpr787	= { FOLLOW_multiplicativeExpr_in_additiveExpr787_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_additiveExpr789  */
static	ANTLR3_BITWORD FOLLOW_set_in_additiveExpr789_bits[]	= { ANTLR3_UINT64_LIT(0x000000000082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_additiveExpr789	= { FOLLOW_set_in_additiveExpr789_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplicativeExpr_in_additiveExpr797  */
static	ANTLR3_BITWORD FOLLOW_multiplicativeExpr_in_additiveExpr797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplicativeExpr_in_additiveExpr797	= { FOLLOW_multiplicativeExpr_in_additiveExpr797_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplicativeExpr_in_additiveExpr802  */
static	ANTLR3_BITWORD FOLLOW_multiplicativeExpr_in_additiveExpr802_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplicativeExpr_in_additiveExpr802	= { FOLLOW_multiplicativeExpr_in_additiveExpr802_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpr_in_multiplicativeExpr813  */
static	ANTLR3_BITWORD FOLLOW_unaryExpr_in_multiplicativeExpr813_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001090000) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpr_in_multiplicativeExpr813	= { FOLLOW_unaryExpr_in_multiplicativeExpr813_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_multiplicativeExpr815  */
static	ANTLR3_BITWORD FOLLOW_set_in_multiplicativeExpr815_bits[]	= { ANTLR3_UINT64_LIT(0x000000000082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_multiplicativeExpr815	= { FOLLOW_set_in_multiplicativeExpr815_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpr_in_multiplicativeExpr827  */
static	ANTLR3_BITWORD FOLLOW_unaryExpr_in_multiplicativeExpr827_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpr_in_multiplicativeExpr827	= { FOLLOW_unaryExpr_in_multiplicativeExpr827_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpr_in_multiplicativeExpr831  */
static	ANTLR3_BITWORD FOLLOW_unaryExpr_in_multiplicativeExpr831_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpr_in_multiplicativeExpr831	= { FOLLOW_unaryExpr_in_multiplicativeExpr831_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unOp_in_unaryExpr842  */
static	ANTLR3_BITWORD FOLLOW_unOp_in_unaryExpr842_bits[]	= { ANTLR3_UINT64_LIT(0x000000000082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_unOp_in_unaryExpr842	= { FOLLOW_unOp_in_unaryExpr842_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpr_in_unaryExpr844  */
static	ANTLR3_BITWORD FOLLOW_unaryExpr_in_unaryExpr844_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpr_in_unaryExpr844	= { FOLLOW_unaryExpr_in_unaryExpr844_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_primaryExpr_in_unaryExpr848  */
static	ANTLR3_BITWORD FOLLOW_primaryExpr_in_unaryExpr848_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_primaryExpr_in_unaryExpr848	= { FOLLOW_primaryExpr_in_unaryExpr848_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_primaryExpr863  */
static	ANTLR3_BITWORD FOLLOW_literal_in_primaryExpr863_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_primaryExpr863	= { FOLLOW_literal_in_primaryExpr863_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_primaryExpr899  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_primaryExpr899_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_primaryExpr899	= { FOLLOW_IDENTIFIER_in_primaryExpr899_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_17_in_primaryExpr932  */
static	ANTLR3_BITWORD FOLLOW_17_in_primaryExpr932_bits[]	= { ANTLR3_UINT64_LIT(0x000000000082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_17_in_primaryExpr932	= { FOLLOW_17_in_primaryExpr932_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_primaryExpr934  */
static	ANTLR3_BITWORD FOLLOW_expr_in_primaryExpr934_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_primaryExpr934	= { FOLLOW_expr_in_primaryExpr934_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_primaryExpr936  */
static	ANTLR3_BITWORD FOLLOW_18_in_primaryExpr936_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_primaryExpr936	= { FOLLOW_18_in_primaryExpr936_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_call_in_primaryExpr968  */
static	ANTLR3_BITWORD FOLLOW_call_in_primaryExpr968_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_call_in_primaryExpr968	= { FOLLOW_call_in_primaryExpr968_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_indexer_in_primaryExpr1007  */
static	ANTLR3_BITWORD FOLLOW_indexer_in_primaryExpr1007_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_indexer_in_primaryExpr1007	= { FOLLOW_indexer_in_primaryExpr1007_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_call1048  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_call1048_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_call1048	= { FOLLOW_IDENTIFIER_in_call1048_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_17_in_call1050  */
static	ANTLR3_BITWORD FOLLOW_17_in_call1050_bits[]	= { ANTLR3_UINT64_LIT(0x000000000086ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_17_in_call1050	= { FOLLOW_17_in_call1050_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_expr_in_call1052  */
static	ANTLR3_BITWORD FOLLOW_list_expr_in_call1052_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_list_expr_in_call1052	= { FOLLOW_list_expr_in_call1052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_call1054  */
static	ANTLR3_BITWORD FOLLOW_18_in_call1054_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_call1054	= { FOLLOW_18_in_call1054_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_indexer1065  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_indexer1065_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_indexer1065	= { FOLLOW_IDENTIFIER_in_indexer1065_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_indexer1067  */
static	ANTLR3_BITWORD FOLLOW_28_in_indexer1067_bits[]	= { ANTLR3_UINT64_LIT(0x000000002082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_indexer1067	= { FOLLOW_28_in_indexer1067_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_expr_in_indexer1069  */
static	ANTLR3_BITWORD FOLLOW_list_expr_in_indexer1069_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_list_expr_in_indexer1069	= { FOLLOW_list_expr_in_indexer1069_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_indexer1071  */
static	ANTLR3_BITWORD FOLLOW_29_in_indexer1071_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_indexer1071	= { FOLLOW_29_in_indexer1071_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_list_expr1112  */
static	ANTLR3_BITWORD FOLLOW_expr_in_list_expr1112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_list_expr1112	= { FOLLOW_expr_in_list_expr1112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_list_expr1115  */
static	ANTLR3_BITWORD FOLLOW_22_in_list_expr1115_bits[]	= { ANTLR3_UINT64_LIT(0x000000000082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_list_expr1115	= { FOLLOW_22_in_list_expr1115_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_list_expr1117  */
static	ANTLR3_BITWORD FOLLOW_expr_in_list_expr1117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_list_expr1117	= { FOLLOW_expr_in_list_expr1117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_synpred34_MyGrammarTest649  */
static	ANTLR3_BITWORD FOLLOW_37_in_synpred34_MyGrammarTest649_bits[]	= { ANTLR3_UINT64_LIT(0x000810828082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_synpred34_MyGrammarTest649	= { FOLLOW_37_in_synpred34_MyGrammarTest649_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_synpred34_MyGrammarTest651  */
static	ANTLR3_BITWORD FOLLOW_statement_in_synpred34_MyGrammarTest651_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_synpred34_MyGrammarTest651	= { FOLLOW_statement_in_synpred34_MyGrammarTest651_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryExpr_in_synpred38_MyGrammarTest751  */
static	ANTLR3_BITWORD FOLLOW_binaryExpr_in_synpred38_MyGrammarTest751_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004200000) };
static  ANTLR3_BITSET_LIST FOLLOW_binaryExpr_in_synpred38_MyGrammarTest751	= { FOLLOW_binaryExpr_in_synpred38_MyGrammarTest751_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_synpred38_MyGrammarTest753  */
static	ANTLR3_BITWORD FOLLOW_set_in_synpred38_MyGrammarTest753_bits[]	= { ANTLR3_UINT64_LIT(0x000000000082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_synpred38_MyGrammarTest753	= { FOLLOW_set_in_synpred38_MyGrammarTest753_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryExpr_in_synpred38_MyGrammarTest761  */
static	ANTLR3_BITWORD FOLLOW_binaryExpr_in_synpred38_MyGrammarTest761_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_binaryExpr_in_synpred38_MyGrammarTest761	= { FOLLOW_binaryExpr_in_synpred38_MyGrammarTest761_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplicativeExpr_in_synpred40_MyGrammarTest787  */
static	ANTLR3_BITWORD FOLLOW_multiplicativeExpr_in_synpred40_MyGrammarTest787_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000900000) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplicativeExpr_in_synpred40_MyGrammarTest787	= { FOLLOW_multiplicativeExpr_in_synpred40_MyGrammarTest787_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_synpred40_MyGrammarTest789  */
static	ANTLR3_BITWORD FOLLOW_set_in_synpred40_MyGrammarTest789_bits[]	= { ANTLR3_UINT64_LIT(0x000000000082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_synpred40_MyGrammarTest789	= { FOLLOW_set_in_synpred40_MyGrammarTest789_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplicativeExpr_in_synpred40_MyGrammarTest797  */
static	ANTLR3_BITWORD FOLLOW_multiplicativeExpr_in_synpred40_MyGrammarTest797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplicativeExpr_in_synpred40_MyGrammarTest797	= { FOLLOW_multiplicativeExpr_in_synpred40_MyGrammarTest797_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpr_in_synpred43_MyGrammarTest813  */
static	ANTLR3_BITWORD FOLLOW_unaryExpr_in_synpred43_MyGrammarTest813_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001090000) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpr_in_synpred43_MyGrammarTest813	= { FOLLOW_unaryExpr_in_synpred43_MyGrammarTest813_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_synpred43_MyGrammarTest815  */
static	ANTLR3_BITWORD FOLLOW_set_in_synpred43_MyGrammarTest815_bits[]	= { ANTLR3_UINT64_LIT(0x000000000082ACF0) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_synpred43_MyGrammarTest815	= { FOLLOW_set_in_synpred43_MyGrammarTest815_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpr_in_synpred43_MyGrammarTest827  */
static	ANTLR3_BITWORD FOLLOW_unaryExpr_in_synpred43_MyGrammarTest827_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpr_in_synpred43_MyGrammarTest827	= { FOLLOW_unaryExpr_in_synpred43_MyGrammarTest827_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start list_identifier
 * MyGrammarTest.g:29:1: list_identifier : ( IDENTIFIER ( ',' IDENTIFIER )* )? ;
 */
static MyGrammarTestParser_list_identifier_return
list_identifier(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_list_identifier_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER1;
    pANTLR3_COMMON_TOKEN    char_literal2;
    pANTLR3_COMMON_TOKEN    IDENTIFIER3;

    pANTLR3_BASE_TREE IDENTIFIER1_tree;
    pANTLR3_BASE_TREE char_literal2_tree;
    pANTLR3_BASE_TREE IDENTIFIER3_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    IDENTIFIER1       = NULL;
    char_literal2       = NULL;
    IDENTIFIER3       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IDENTIFIER1_tree   = NULL;
    char_literal2_tree   = NULL;
    IDENTIFIER3_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:29:16: ( ( IDENTIFIER ( ',' IDENTIFIER )* )? )
        // MyGrammarTest.g:29:18: ( IDENTIFIER ( ',' IDENTIFIER )* )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // MyGrammarTest.g:29:18: ( IDENTIFIER ( ',' IDENTIFIER )* )?
            {
                int alt2=2;
                switch ( LA(1) )
                {
                    case IDENTIFIER:
                    	{
                    		alt2=1;
                    	}
                        break;
                }

                switch (alt2)
                {
            	case 1:
            	    // MyGrammarTest.g:29:19: IDENTIFIER ( ',' IDENTIFIER )*
            	    {
            	        IDENTIFIER1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_list_identifier298);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelist_identifierEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        IDENTIFIER1_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER1));
            	        ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER1_tree);
            	        }

            	        // MyGrammarTest.g:29:30: ( ',' IDENTIFIER )*

            	        for (;;)
            	        {
            	            int alt1=2;
            	            switch ( LA(1) )
            	            {
            	            case 22:
            	            	{
            	            		alt1=1;
            	            	}
            	                break;

            	            }

            	            switch (alt1)
            	            {
            	        	case 1:
            	        	    // MyGrammarTest.g:29:31: ',' IDENTIFIER
            	        	    {
            	        	        char_literal2 = (pANTLR3_COMMON_TOKEN) MATCHT(22, &FOLLOW_22_in_list_identifier301);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelist_identifierEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) {
            	        	        char_literal2_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal2));
            	        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal2_tree);
            	        	        }

            	        	        IDENTIFIER3 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_list_identifier303);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelist_identifierEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) {
            	        	        IDENTIFIER3_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER3));
            	        	        ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER3_tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop1;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop1: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulelist_identifierEx; /* Prevent compiler warnings */
    rulelist_identifierEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end list_identifier */

/**
 * $ANTLR start list_item
 * MyGrammarTest.g:31:1: list_item : ( item ( ',' item )* )? ;
 */
static MyGrammarTestParser_list_item_return
list_item(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_list_item_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal5;
    MyGrammarTestParser_item_return item4;
    #undef	RETURN_TYPE_item4
    #define	RETURN_TYPE_item4 MyGrammarTestParser_item_return

    MyGrammarTestParser_item_return item6;
    #undef	RETURN_TYPE_item6
    #define	RETURN_TYPE_item6 MyGrammarTestParser_item_return

    pANTLR3_BASE_TREE char_literal5_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal5       = NULL;
    item4.tree = NULL;

    item6.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal5_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:31:11: ( ( item ( ',' item )* )? )
        // MyGrammarTest.g:31:13: ( item ( ',' item )* )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // MyGrammarTest.g:31:13: ( item ( ',' item )* )?
            {
                int alt4=2;
                switch ( LA(1) )
                {
                    case BITS_LITERAL:
                    case BOOL_LITERAL:
                    case CHAR:
                    case DEC_LITERAL:
                    case HEX_LITERAL:
                    case STRING_LIT:
                    	{
                    		alt4=1;
                    	}
                        break;
                }

                switch (alt4)
                {
            	case 1:
            	    // MyGrammarTest.g:31:14: item ( ',' item )*
            	    {
            	        FOLLOWPUSH(FOLLOW_item_in_list_item317);
            	        item4=item(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelist_itemEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, item4.tree);

            	        // MyGrammarTest.g:31:19: ( ',' item )*

            	        for (;;)
            	        {
            	            int alt3=2;
            	            switch ( LA(1) )
            	            {
            	            case 22:
            	            	{
            	            		alt3=1;
            	            	}
            	                break;

            	            }

            	            switch (alt3)
            	            {
            	        	case 1:
            	        	    // MyGrammarTest.g:31:20: ',' item
            	        	    {
            	        	        char_literal5 = (pANTLR3_COMMON_TOKEN) MATCHT(22, &FOLLOW_22_in_list_item320);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelist_itemEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) {
            	        	        char_literal5_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal5));
            	        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal5_tree);
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_item_in_list_item322);
            	        	        item6=item(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelist_itemEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, item6.tree);

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop3;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop3: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulelist_itemEx; /* Prevent compiler warnings */
    rulelist_itemEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end list_item */

/**
 * $ANTLR start item
 * MyGrammarTest.g:32:10: fragment item : ( BOOL_LITERAL | CHAR | STRING_LIT | HEX_LITERAL | BITS_LITERAL | DEC_LITERAL ) ;
 */
static MyGrammarTestParser_item_return
item(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_item_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set7;

    pANTLR3_BASE_TREE set7_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set7       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set7_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:32:15: ( ( BOOL_LITERAL | CHAR | STRING_LIT | HEX_LITERAL | BITS_LITERAL | DEC_LITERAL ) )
        // MyGrammarTest.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set7=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( ((LA(1) >= BITS_LITERAL) && (LA(1) <= DEC_LITERAL)) || LA(1) == HEX_LITERAL || LA(1) == STRING_LIT )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set7))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleitemEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleitemEx; /* Prevent compiler warnings */
    ruleitemEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end item */

/**
 * $ANTLR start source
 * MyGrammarTest.g:34:1: source : ( sourceItem )* ;
 */
static MyGrammarTestParser_source_return
source(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_source_return retval;


    pANTLR3_BASE_TREE root_0;

    MyGrammarTestParser_sourceItem_return sourceItem8;
    #undef	RETURN_TYPE_sourceItem8
    #define	RETURN_TYPE_sourceItem8 MyGrammarTestParser_sourceItem_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sourceItem8.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // MyGrammarTest.g:34:8: ( ( sourceItem )* )
        // MyGrammarTest.g:34:10: ( sourceItem )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // MyGrammarTest.g:34:10: ( sourceItem )*

            for (;;)
            {
                int alt5=2;
                switch ( LA(1) )
                {
                case 42:
                	{
                		alt5=1;
                	}
                    break;

                }

                switch (alt5)
                {
            	case 1:
            	    // MyGrammarTest.g:34:10: sourceItem
            	    {
            	        FOLLOWPUSH(FOLLOW_sourceItem_in_source367);
            	        sourceItem8=sourceItem(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesourceEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, sourceItem8.tree);

            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesourceEx; /* Prevent compiler warnings */
    rulesourceEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end source */

/**
 * $ANTLR start sourceItem
 * MyGrammarTest.g:36:1: sourceItem : funcDef ;
 */
static MyGrammarTestParser_sourceItem_return
sourceItem(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_sourceItem_return retval;


    pANTLR3_BASE_TREE root_0;

    MyGrammarTestParser_funcDef_return funcDef9;
    #undef	RETURN_TYPE_funcDef9
    #define	RETURN_TYPE_funcDef9 MyGrammarTestParser_funcDef_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    funcDef9.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // MyGrammarTest.g:36:12: ( funcDef )
        // MyGrammarTest.g:36:14: funcDef
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_funcDef_in_sourceItem377);
            funcDef9=funcDef(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesourceItemEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, funcDef9.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulesourceItemEx; /* Prevent compiler warnings */
    rulesourceItemEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end sourceItem */

/**
 * $ANTLR start funcDef
 * MyGrammarTest.g:37:10: fragment funcDef : 'method' funcSignature ( body | ';' ) ;
 */
static MyGrammarTestParser_funcDef_return
funcDef(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_funcDef_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal10;
    pANTLR3_COMMON_TOKEN    char_literal13;
    MyGrammarTestParser_funcSignature_return funcSignature11;
    #undef	RETURN_TYPE_funcSignature11
    #define	RETURN_TYPE_funcSignature11 MyGrammarTestParser_funcSignature_return

    MyGrammarTestParser_body_return body12;
    #undef	RETURN_TYPE_body12
    #define	RETURN_TYPE_body12 MyGrammarTestParser_body_return

    pANTLR3_BASE_TREE string_literal10_tree;
    pANTLR3_BASE_TREE char_literal13_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal10       = NULL;
    char_literal13       = NULL;
    funcSignature11.tree = NULL;

    body12.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal10_tree   = NULL;
    char_literal13_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:37:18: ( 'method' funcSignature ( body | ';' ) )
        // MyGrammarTest.g:37:20: 'method' funcSignature ( body | ';' )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            string_literal10 = (pANTLR3_COMMON_TOKEN) MATCHT(42, &FOLLOW_42_in_funcDef387);
            if  (HASEXCEPTION())
            {
                goto rulefuncDefEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal10_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal10));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal10_tree);
            }

            FOLLOWPUSH(FOLLOW_funcSignature_in_funcDef389);
            funcSignature11=funcSignature(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefuncDefEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, funcSignature11.tree);

            // MyGrammarTest.g:37:43: ( body | ';' )
            {
                int alt6=2;
                switch ( LA(1) )
                {
                case 31:
                case 50:
                	{
                		alt6=1;
                	}
                    break;
                case 27:
                	{
                		alt6=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return retval;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 6;
                    EXCEPTION->state        = 0;


                    goto rulefuncDefEx;

                }

                switch (alt6)
                {
            	case 1:
            	    // MyGrammarTest.g:37:45: body
            	    {
            	        FOLLOWPUSH(FOLLOW_body_in_funcDef393);
            	        body12=body(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefuncDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, body12.tree);

            	    }
            	    break;
            	case 2:
            	    // MyGrammarTest.g:37:52: ';'
            	    {
            	        char_literal13 = (pANTLR3_COMMON_TOKEN) MATCHT(27, &FOLLOW_27_in_funcDef397);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefuncDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        char_literal13_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal13));
            	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal13_tree);
            	        }

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulefuncDefEx; /* Prevent compiler warnings */
    rulefuncDefEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end funcDef */

/**
 * $ANTLR start body
 * MyGrammarTest.g:38:10: fragment body : ( 'var' ( list_identifier ( ':' typeRef )? ';' )* )? blockStatement ;
 */
static MyGrammarTestParser_body_return
body(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_body_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal14;
    pANTLR3_COMMON_TOKEN    char_literal16;
    pANTLR3_COMMON_TOKEN    char_literal18;
    MyGrammarTestParser_list_identifier_return list_identifier15;
    #undef	RETURN_TYPE_list_identifier15
    #define	RETURN_TYPE_list_identifier15 MyGrammarTestParser_list_identifier_return

    MyGrammarTestParser_typeRef_return typeRef17;
    #undef	RETURN_TYPE_typeRef17
    #define	RETURN_TYPE_typeRef17 MyGrammarTestParser_typeRef_return

    MyGrammarTestParser_blockStatement_return blockStatement19;
    #undef	RETURN_TYPE_blockStatement19
    #define	RETURN_TYPE_blockStatement19 MyGrammarTestParser_blockStatement_return

    pANTLR3_BASE_TREE string_literal14_tree;
    pANTLR3_BASE_TREE char_literal16_tree;
    pANTLR3_BASE_TREE char_literal18_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal14       = NULL;
    char_literal16       = NULL;
    char_literal18       = NULL;
    list_identifier15.tree = NULL;

    typeRef17.tree = NULL;

    blockStatement19.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal14_tree   = NULL;
    char_literal16_tree   = NULL;
    char_literal18_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:38:15: ( ( 'var' ( list_identifier ( ':' typeRef )? ';' )* )? blockStatement )
        // MyGrammarTest.g:38:17: ( 'var' ( list_identifier ( ':' typeRef )? ';' )* )? blockStatement
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // MyGrammarTest.g:38:17: ( 'var' ( list_identifier ( ':' typeRef )? ';' )* )?
            {
                int alt9=2;
                switch ( LA(1) )
                {
                    case 50:
                    	{
                    		alt9=1;
                    	}
                        break;
                }

                switch (alt9)
                {
            	case 1:
            	    // MyGrammarTest.g:38:19: 'var' ( list_identifier ( ':' typeRef )? ';' )*
            	    {
            	        string_literal14 = (pANTLR3_COMMON_TOKEN) MATCHT(50, &FOLLOW_50_in_body410);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebodyEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        string_literal14_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal14));
            	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal14_tree);
            	        }

            	        // MyGrammarTest.g:38:25: ( list_identifier ( ':' typeRef )? ';' )*

            	        for (;;)
            	        {
            	            int alt8=2;
            	            switch ( LA(1) )
            	            {
            	            case IDENTIFIER:
            	            case 25:
            	            case 27:
            	            	{
            	            		alt8=1;
            	            	}
            	                break;

            	            }

            	            switch (alt8)
            	            {
            	        	case 1:
            	        	    // MyGrammarTest.g:38:27: list_identifier ( ':' typeRef )? ';'
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_list_identifier_in_body414);
            	        	        list_identifier15=list_identifier(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebodyEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, list_identifier15.tree);

            	        	        // MyGrammarTest.g:38:43: ( ':' typeRef )?
            	        	        {
            	        	            int alt7=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case 25:
            	        	                	{
            	        	                		alt7=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt7)
            	        	            {
            	        	        	case 1:
            	        	        	    // MyGrammarTest.g:38:44: ':' typeRef
            	        	        	    {
            	        	        	        char_literal16 = (pANTLR3_COMMON_TOKEN) MATCHT(25, &FOLLOW_25_in_body417);
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulebodyEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }

            	        	        	        if ( BACKTRACKING==0 ) {
            	        	        	        char_literal16_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal16));
            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal16_tree);
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_typeRef_in_body419);
            	        	        	        typeRef17=typeRef(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulebodyEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }

            	        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typeRef17.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        char_literal18 = (pANTLR3_COMMON_TOKEN) MATCHT(27, &FOLLOW_27_in_body423);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebodyEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) {
            	        	        char_literal18_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal18));
            	        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal18_tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop8;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop8: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_blockStatement_in_body431);
            blockStatement19=blockStatement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebodyEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, blockStatement19.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulebodyEx; /* Prevent compiler warnings */
    rulebodyEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end body */

/**
 * $ANTLR start typeRef
 * MyGrammarTest.g:40:1: typeRef : ( builtin | custom | array ) ;
 */
static MyGrammarTestParser_typeRef_return
typeRef(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_typeRef_return retval;


    pANTLR3_BASE_TREE root_0;

    MyGrammarTestParser_builtin_return builtin20;
    #undef	RETURN_TYPE_builtin20
    #define	RETURN_TYPE_builtin20 MyGrammarTestParser_builtin_return

    MyGrammarTestParser_custom_return custom21;
    #undef	RETURN_TYPE_custom21
    #define	RETURN_TYPE_custom21 MyGrammarTestParser_custom_return

    MyGrammarTestParser_array_return array22;
    #undef	RETURN_TYPE_array22
    #define	RETURN_TYPE_array22 MyGrammarTestParser_array_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    builtin20.tree = NULL;

    custom21.tree = NULL;

    array22.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // MyGrammarTest.g:40:9: ( ( builtin | custom | array ) )
        // MyGrammarTest.g:40:11: ( builtin | custom | array )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // MyGrammarTest.g:40:11: ( builtin | custom | array )
            {
                int alt10=3;
                switch ( LA(1) )
                {
                case 32:
                case 34:
                case 35:
                case 40:
                case 41:
                case 45:
                case 47:
                case 48:
                	{
                		alt10=1;
                	}
                    break;
                case IDENTIFIER:
                	{
                		alt10=2;
                	}
                    break;
                case 30:
                	{
                		alt10=3;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return retval;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 10;
                    EXCEPTION->state        = 0;


                    goto ruletypeRefEx;

                }

                switch (alt10)
                {
            	case 1:
            	    // MyGrammarTest.g:40:12: builtin
            	    {
            	        FOLLOWPUSH(FOLLOW_builtin_in_typeRef442);
            	        builtin20=builtin(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeRefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, builtin20.tree);

            	    }
            	    break;
            	case 2:
            	    // MyGrammarTest.g:40:22: custom
            	    {
            	        FOLLOWPUSH(FOLLOW_custom_in_typeRef446);
            	        custom21=custom(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeRefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, custom21.tree);

            	    }
            	    break;
            	case 3:
            	    // MyGrammarTest.g:40:31: array
            	    {
            	        FOLLOWPUSH(FOLLOW_array_in_typeRef450);
            	        array22=array(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeRefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, array22.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruletypeRefEx; /* Prevent compiler warnings */
    ruletypeRefEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end typeRef */

/**
 * $ANTLR start builtin
 * MyGrammarTest.g:41:10: fragment builtin : ( 'bool' | 'byte' | 'int' | 'uint' | 'long' | 'ulong' | 'char' | 'string' ) ;
 */
static MyGrammarTestParser_builtin_return
builtin(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_builtin_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set23;

    pANTLR3_BASE_TREE set23_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set23       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set23_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:41:18: ( ( 'bool' | 'byte' | 'int' | 'uint' | 'long' | 'ulong' | 'char' | 'string' ) )
        // MyGrammarTest.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set23=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == 32 || ((LA(1) >= 34) && (LA(1) <= 35)) || ((LA(1) >= 40) && (LA(1) <= 41)) || LA(1) == 45 || ((LA(1) >= 47) && (LA(1) <= 48)) )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set23))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulebuiltinEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebuiltinEx; /* Prevent compiler warnings */
    rulebuiltinEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end builtin */

/**
 * $ANTLR start custom
 * MyGrammarTest.g:42:10: fragment custom : IDENTIFIER ;
 */
static MyGrammarTestParser_custom_return
custom(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_custom_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER24;

    pANTLR3_BASE_TREE IDENTIFIER24_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    IDENTIFIER24       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IDENTIFIER24_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:42:17: ( IDENTIFIER )
        // MyGrammarTest.g:42:19: IDENTIFIER
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            IDENTIFIER24 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_custom499);
            if  (HASEXCEPTION())
            {
                goto rulecustomEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            IDENTIFIER24_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER24));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER24_tree);
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulecustomEx; /* Prevent compiler warnings */
    rulecustomEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end custom */

/**
 * $ANTLR start array
 * MyGrammarTest.g:43:10: fragment array : 'array' '[' ( ',' )* ']' 'of' typeRef ;
 */
static MyGrammarTestParser_array_return
array(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_array_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal25;
    pANTLR3_COMMON_TOKEN    char_literal26;
    pANTLR3_COMMON_TOKEN    char_literal27;
    pANTLR3_COMMON_TOKEN    char_literal28;
    pANTLR3_COMMON_TOKEN    string_literal29;
    MyGrammarTestParser_typeRef_return typeRef30;
    #undef	RETURN_TYPE_typeRef30
    #define	RETURN_TYPE_typeRef30 MyGrammarTestParser_typeRef_return

    pANTLR3_BASE_TREE string_literal25_tree;
    pANTLR3_BASE_TREE char_literal26_tree;
    pANTLR3_BASE_TREE char_literal27_tree;
    pANTLR3_BASE_TREE char_literal28_tree;
    pANTLR3_BASE_TREE string_literal29_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal25       = NULL;
    char_literal26       = NULL;
    char_literal27       = NULL;
    char_literal28       = NULL;
    string_literal29       = NULL;
    typeRef30.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal25_tree   = NULL;
    char_literal26_tree   = NULL;
    char_literal27_tree   = NULL;
    char_literal28_tree   = NULL;
    string_literal29_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:43:16: ( 'array' '[' ( ',' )* ']' 'of' typeRef )
        // MyGrammarTest.g:43:18: 'array' '[' ( ',' )* ']' 'of' typeRef
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            string_literal25 = (pANTLR3_COMMON_TOKEN) MATCHT(30, &FOLLOW_30_in_array509);
            if  (HASEXCEPTION())
            {
                goto rulearrayEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal25_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal25));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal25_tree);
            }

            char_literal26 = (pANTLR3_COMMON_TOKEN) MATCHT(28, &FOLLOW_28_in_array511);
            if  (HASEXCEPTION())
            {
                goto rulearrayEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal26_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal26));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal26_tree);
            }

            // MyGrammarTest.g:43:30: ( ',' )*

            for (;;)
            {
                int alt11=2;
                switch ( LA(1) )
                {
                case 22:
                	{
                		alt11=1;
                	}
                    break;

                }

                switch (alt11)
                {
            	case 1:
            	    // MyGrammarTest.g:43:31: ','
            	    {
            	        char_literal27 = (pANTLR3_COMMON_TOKEN) MATCHT(22, &FOLLOW_22_in_array514);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulearrayEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        char_literal27_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal27));
            	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal27_tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop11;	/* break out of the loop */
            	    break;
                }
            }
            loop11: ; /* Jump out to here if this rule does not match */


            char_literal28 = (pANTLR3_COMMON_TOKEN) MATCHT(29, &FOLLOW_29_in_array518);
            if  (HASEXCEPTION())
            {
                goto rulearrayEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal28_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal28));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal28_tree);
            }

            string_literal29 = (pANTLR3_COMMON_TOKEN) MATCHT(43, &FOLLOW_43_in_array520);
            if  (HASEXCEPTION())
            {
                goto rulearrayEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal29_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal29));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal29_tree);
            }

            FOLLOWPUSH(FOLLOW_typeRef_in_array522);
            typeRef30=typeRef(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulearrayEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typeRef30.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulearrayEx; /* Prevent compiler warnings */
    rulearrayEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end array */

/**
 * $ANTLR start funcSignature
 * MyGrammarTest.g:45:1: funcSignature : IDENTIFIER '(' list_argDef ')' ( ':' typeRef )? ;
 */
static MyGrammarTestParser_funcSignature_return
funcSignature(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_funcSignature_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER31;
    pANTLR3_COMMON_TOKEN    char_literal32;
    pANTLR3_COMMON_TOKEN    char_literal34;
    pANTLR3_COMMON_TOKEN    char_literal35;
    MyGrammarTestParser_list_argDef_return list_argDef33;
    #undef	RETURN_TYPE_list_argDef33
    #define	RETURN_TYPE_list_argDef33 MyGrammarTestParser_list_argDef_return

    MyGrammarTestParser_typeRef_return typeRef36;
    #undef	RETURN_TYPE_typeRef36
    #define	RETURN_TYPE_typeRef36 MyGrammarTestParser_typeRef_return

    pANTLR3_BASE_TREE IDENTIFIER31_tree;
    pANTLR3_BASE_TREE char_literal32_tree;
    pANTLR3_BASE_TREE char_literal34_tree;
    pANTLR3_BASE_TREE char_literal35_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    IDENTIFIER31       = NULL;
    char_literal32       = NULL;
    char_literal34       = NULL;
    char_literal35       = NULL;
    list_argDef33.tree = NULL;

    typeRef36.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IDENTIFIER31_tree   = NULL;
    char_literal32_tree   = NULL;
    char_literal34_tree   = NULL;
    char_literal35_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:45:15: ( IDENTIFIER '(' list_argDef ')' ( ':' typeRef )? )
        // MyGrammarTest.g:45:17: IDENTIFIER '(' list_argDef ')' ( ':' typeRef )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            IDENTIFIER31 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_funcSignature530);
            if  (HASEXCEPTION())
            {
                goto rulefuncSignatureEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            IDENTIFIER31_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER31));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER31_tree);
            }

            char_literal32 = (pANTLR3_COMMON_TOKEN) MATCHT(17, &FOLLOW_17_in_funcSignature532);
            if  (HASEXCEPTION())
            {
                goto rulefuncSignatureEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal32_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal32));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal32_tree);
            }

            FOLLOWPUSH(FOLLOW_list_argDef_in_funcSignature534);
            list_argDef33=list_argDef(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefuncSignatureEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, list_argDef33.tree);

            char_literal34 = (pANTLR3_COMMON_TOKEN) MATCHT(18, &FOLLOW_18_in_funcSignature536);
            if  (HASEXCEPTION())
            {
                goto rulefuncSignatureEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal34_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal34));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal34_tree);
            }

            // MyGrammarTest.g:45:48: ( ':' typeRef )?
            {
                int alt12=2;
                switch ( LA(1) )
                {
                    case 25:
                    	{
                    		alt12=1;
                    	}
                        break;
                }

                switch (alt12)
                {
            	case 1:
            	    // MyGrammarTest.g:45:49: ':' typeRef
            	    {
            	        char_literal35 = (pANTLR3_COMMON_TOKEN) MATCHT(25, &FOLLOW_25_in_funcSignature539);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefuncSignatureEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        char_literal35_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal35));
            	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal35_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_typeRef_in_funcSignature541);
            	        typeRef36=typeRef(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefuncSignatureEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typeRef36.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulefuncSignatureEx; /* Prevent compiler warnings */
    rulefuncSignatureEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end funcSignature */

/**
 * $ANTLR start list_argDef
 * MyGrammarTest.g:46:10: fragment list_argDef : ( argDef ( ',' argDef )* )? ;
 */
static MyGrammarTestParser_list_argDef_return
list_argDef(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_list_argDef_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal38;
    MyGrammarTestParser_argDef_return argDef37;
    #undef	RETURN_TYPE_argDef37
    #define	RETURN_TYPE_argDef37 MyGrammarTestParser_argDef_return

    MyGrammarTestParser_argDef_return argDef39;
    #undef	RETURN_TYPE_argDef39
    #define	RETURN_TYPE_argDef39 MyGrammarTestParser_argDef_return

    pANTLR3_BASE_TREE char_literal38_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal38       = NULL;
    argDef37.tree = NULL;

    argDef39.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal38_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:46:22: ( ( argDef ( ',' argDef )* )? )
        // MyGrammarTest.g:46:24: ( argDef ( ',' argDef )* )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // MyGrammarTest.g:46:24: ( argDef ( ',' argDef )* )?
            {
                int alt14=2;
                switch ( LA(1) )
                {
                    case IDENTIFIER:
                    	{
                    		alt14=1;
                    	}
                        break;
                }

                switch (alt14)
                {
            	case 1:
            	    // MyGrammarTest.g:46:25: argDef ( ',' argDef )*
            	    {
            	        FOLLOWPUSH(FOLLOW_argDef_in_list_argDef559);
            	        argDef37=argDef(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelist_argDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, argDef37.tree);

            	        // MyGrammarTest.g:46:32: ( ',' argDef )*

            	        for (;;)
            	        {
            	            int alt13=2;
            	            switch ( LA(1) )
            	            {
            	            case 22:
            	            	{
            	            		alt13=1;
            	            	}
            	                break;

            	            }

            	            switch (alt13)
            	            {
            	        	case 1:
            	        	    // MyGrammarTest.g:46:33: ',' argDef
            	        	    {
            	        	        char_literal38 = (pANTLR3_COMMON_TOKEN) MATCHT(22, &FOLLOW_22_in_list_argDef562);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelist_argDefEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) {
            	        	        char_literal38_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal38));
            	        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal38_tree);
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_argDef_in_list_argDef564);
            	        	        argDef39=argDef(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelist_argDefEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, argDef39.tree);

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop13;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop13: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulelist_argDefEx; /* Prevent compiler warnings */
    rulelist_argDefEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end list_argDef */

/**
 * $ANTLR start argDef
 * MyGrammarTest.g:47:10: fragment argDef : IDENTIFIER ( ':' typeRef )? ;
 */
static MyGrammarTestParser_argDef_return
argDef(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_argDef_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER40;
    pANTLR3_COMMON_TOKEN    char_literal41;
    MyGrammarTestParser_typeRef_return typeRef42;
    #undef	RETURN_TYPE_typeRef42
    #define	RETURN_TYPE_typeRef42 MyGrammarTestParser_typeRef_return

    pANTLR3_BASE_TREE IDENTIFIER40_tree;
    pANTLR3_BASE_TREE char_literal41_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    IDENTIFIER40       = NULL;
    char_literal41       = NULL;
    typeRef42.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IDENTIFIER40_tree   = NULL;
    char_literal41_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:47:17: ( IDENTIFIER ( ':' typeRef )? )
        // MyGrammarTest.g:47:19: IDENTIFIER ( ':' typeRef )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            IDENTIFIER40 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_argDef584);
            if  (HASEXCEPTION())
            {
                goto ruleargDefEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            IDENTIFIER40_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER40));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER40_tree);
            }

            // MyGrammarTest.g:47:30: ( ':' typeRef )?
            {
                int alt15=2;
                switch ( LA(1) )
                {
                    case 25:
                    	{
                    		alt15=1;
                    	}
                        break;
                }

                switch (alt15)
                {
            	case 1:
            	    // MyGrammarTest.g:47:31: ':' typeRef
            	    {
            	        char_literal41 = (pANTLR3_COMMON_TOKEN) MATCHT(25, &FOLLOW_25_in_argDef587);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleargDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        char_literal41_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal41));
            	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal41_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_typeRef_in_argDef589);
            	        typeRef42=typeRef(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleargDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typeRef42.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleargDefEx; /* Prevent compiler warnings */
    ruleargDefEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end argDef */

/**
 * $ANTLR start statement
 * MyGrammarTest.g:52:1: statement : ( ifStatement | blockStatement | whileStatement | doStatement | breakStatement | expressionStatement ) ;
 */
static MyGrammarTestParser_statement_return
statement(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_statement_return retval;


    pANTLR3_BASE_TREE root_0;

    MyGrammarTestParser_ifStatement_return ifStatement43;
    #undef	RETURN_TYPE_ifStatement43
    #define	RETURN_TYPE_ifStatement43 MyGrammarTestParser_ifStatement_return

    MyGrammarTestParser_blockStatement_return blockStatement44;
    #undef	RETURN_TYPE_blockStatement44
    #define	RETURN_TYPE_blockStatement44 MyGrammarTestParser_blockStatement_return

    MyGrammarTestParser_whileStatement_return whileStatement45;
    #undef	RETURN_TYPE_whileStatement45
    #define	RETURN_TYPE_whileStatement45 MyGrammarTestParser_whileStatement_return

    MyGrammarTestParser_doStatement_return doStatement46;
    #undef	RETURN_TYPE_doStatement46
    #define	RETURN_TYPE_doStatement46 MyGrammarTestParser_doStatement_return

    MyGrammarTestParser_breakStatement_return breakStatement47;
    #undef	RETURN_TYPE_breakStatement47
    #define	RETURN_TYPE_breakStatement47 MyGrammarTestParser_breakStatement_return

    MyGrammarTestParser_expressionStatement_return expressionStatement48;
    #undef	RETURN_TYPE_expressionStatement48
    #define	RETURN_TYPE_expressionStatement48 MyGrammarTestParser_expressionStatement_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    ifStatement43.tree = NULL;

    blockStatement44.tree = NULL;

    whileStatement45.tree = NULL;

    doStatement46.tree = NULL;

    breakStatement47.tree = NULL;

    expressionStatement48.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // MyGrammarTest.g:52:11: ( ( ifStatement | blockStatement | whileStatement | doStatement | breakStatement | expressionStatement ) )
        // MyGrammarTest.g:52:13: ( ifStatement | blockStatement | whileStatement | doStatement | breakStatement | expressionStatement )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // MyGrammarTest.g:52:13: ( ifStatement | blockStatement | whileStatement | doStatement | breakStatement | expressionStatement )
            {
                int alt16=6;
                switch ( LA(1) )
                {
                case 39:
                	{
                		alt16=1;
                	}
                    break;
                case 31:
                	{
                		alt16=2;
                	}
                    break;
                case 51:
                	{
                		alt16=3;
                	}
                    break;
                case 44:
                	{
                		alt16=4;
                	}
                    break;
                case 33:
                	{
                		alt16=5;
                	}
                    break;
                case BITS_LITERAL:
                case BOOL_LITERAL:
                case CHAR:
                case DEC_LITERAL:
                case HEX_LITERAL:
                case IDENTIFIER:
                case STRING_LIT:
                case 15:
                case 17:
                case 23:
                	{
                		alt16=6;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return retval;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 16;
                    EXCEPTION->state        = 0;


                    goto rulestatementEx;

                }

                switch (alt16)
                {
            	case 1:
            	    // MyGrammarTest.g:52:15: ifStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_ifStatement_in_statement605);
            	        ifStatement43=ifStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, ifStatement43.tree);

            	    }
            	    break;
            	case 2:
            	    // MyGrammarTest.g:52:29: blockStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_blockStatement_in_statement609);
            	        blockStatement44=blockStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, blockStatement44.tree);

            	    }
            	    break;
            	case 3:
            	    // MyGrammarTest.g:52:46: whileStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_whileStatement_in_statement613);
            	        whileStatement45=whileStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, whileStatement45.tree);

            	    }
            	    break;
            	case 4:
            	    // MyGrammarTest.g:52:63: doStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_doStatement_in_statement617);
            	        doStatement46=doStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, doStatement46.tree);

            	    }
            	    break;
            	case 5:
            	    // MyGrammarTest.g:53:7: breakStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_breakStatement_in_statement625);
            	        breakStatement47=breakStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, breakStatement47.tree);

            	    }
            	    break;
            	case 6:
            	    // MyGrammarTest.g:53:24: expressionStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_expressionStatement_in_statement629);
            	        expressionStatement48=expressionStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expressionStatement48.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end statement */

/**
 * $ANTLR start ifStatement
 * MyGrammarTest.g:55:1: ifStatement : 'if' expr 'then' statement ( 'else' statement )? ;
 */
static MyGrammarTestParser_ifStatement_return
ifStatement(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_ifStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal49;
    pANTLR3_COMMON_TOKEN    string_literal51;
    pANTLR3_COMMON_TOKEN    string_literal53;
    MyGrammarTestParser_expr_return expr50;
    #undef	RETURN_TYPE_expr50
    #define	RETURN_TYPE_expr50 MyGrammarTestParser_expr_return

    MyGrammarTestParser_statement_return statement52;
    #undef	RETURN_TYPE_statement52
    #define	RETURN_TYPE_statement52 MyGrammarTestParser_statement_return

    MyGrammarTestParser_statement_return statement54;
    #undef	RETURN_TYPE_statement54
    #define	RETURN_TYPE_statement54 MyGrammarTestParser_statement_return

    pANTLR3_BASE_TREE string_literal49_tree;
    pANTLR3_BASE_TREE string_literal51_tree;
    pANTLR3_BASE_TREE string_literal53_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal49       = NULL;
    string_literal51       = NULL;
    string_literal53       = NULL;
    expr50.tree = NULL;

    statement52.tree = NULL;

    statement54.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal49_tree   = NULL;
    string_literal51_tree   = NULL;
    string_literal53_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:55:13: ( 'if' expr 'then' statement ( 'else' statement )? )
        // MyGrammarTest.g:55:15: 'if' expr 'then' statement ( 'else' statement )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            string_literal49 = (pANTLR3_COMMON_TOKEN) MATCHT(39, &FOLLOW_39_in_ifStatement640);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal49_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal49));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal49_tree);
            }

            FOLLOWPUSH(FOLLOW_expr_in_ifStatement642);
            expr50=expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expr50.tree);

            string_literal51 = (pANTLR3_COMMON_TOKEN) MATCHT(46, &FOLLOW_46_in_ifStatement644);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal51_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal51));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal51_tree);
            }

            FOLLOWPUSH(FOLLOW_statement_in_ifStatement646);
            statement52=statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, statement52.tree);

            // MyGrammarTest.g:55:42: ( 'else' statement )?
            {
                int alt17=2;
                switch ( LA(1) )
                {
                    case 37:
                    	{
                    		{
                    		    int LA17_1 = LA(2);
                    		    if ( (synpred34_MyGrammarTest(ctx)))
                    		    {
                    		        alt17=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt17)
                {
            	case 1:
            	    // MyGrammarTest.g:55:43: 'else' statement
            	    {
            	        string_literal53 = (pANTLR3_COMMON_TOKEN) MATCHT(37, &FOLLOW_37_in_ifStatement649);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        string_literal53_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal53));
            	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal53_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_statement_in_ifStatement651);
            	        statement54=statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, statement54.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleifStatementEx; /* Prevent compiler warnings */
    ruleifStatementEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end ifStatement */

/**
 * $ANTLR start blockStatement
 * MyGrammarTest.g:57:1: blockStatement : 'begin' ( statement )* 'end' ';' ;
 */
static MyGrammarTestParser_blockStatement_return
blockStatement(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_blockStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal55;
    pANTLR3_COMMON_TOKEN    string_literal57;
    pANTLR3_COMMON_TOKEN    char_literal58;
    MyGrammarTestParser_statement_return statement56;
    #undef	RETURN_TYPE_statement56
    #define	RETURN_TYPE_statement56 MyGrammarTestParser_statement_return

    pANTLR3_BASE_TREE string_literal55_tree;
    pANTLR3_BASE_TREE string_literal57_tree;
    pANTLR3_BASE_TREE char_literal58_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal55       = NULL;
    string_literal57       = NULL;
    char_literal58       = NULL;
    statement56.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal55_tree   = NULL;
    string_literal57_tree   = NULL;
    char_literal58_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:57:16: ( 'begin' ( statement )* 'end' ';' )
        // MyGrammarTest.g:57:18: 'begin' ( statement )* 'end' ';'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            string_literal55 = (pANTLR3_COMMON_TOKEN) MATCHT(31, &FOLLOW_31_in_blockStatement662);
            if  (HASEXCEPTION())
            {
                goto ruleblockStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal55_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal55));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal55_tree);
            }

            // MyGrammarTest.g:57:26: ( statement )*

            for (;;)
            {
                int alt18=2;
                switch ( LA(1) )
                {
                case BITS_LITERAL:
                case BOOL_LITERAL:
                case CHAR:
                case DEC_LITERAL:
                case HEX_LITERAL:
                case IDENTIFIER:
                case STRING_LIT:
                case 15:
                case 17:
                case 23:
                case 31:
                case 33:
                case 39:
                case 44:
                case 51:
                	{
                		alt18=1;
                	}
                    break;

                }

                switch (alt18)
                {
            	case 1:
            	    // MyGrammarTest.g:57:26: statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_blockStatement664);
            	        statement56=statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleblockStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, statement56.tree);

            	    }
            	    break;

            	default:
            	    goto loop18;	/* break out of the loop */
            	    break;
                }
            }
            loop18: ; /* Jump out to here if this rule does not match */


            string_literal57 = (pANTLR3_COMMON_TOKEN) MATCHT(38, &FOLLOW_38_in_blockStatement667);
            if  (HASEXCEPTION())
            {
                goto ruleblockStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal57_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal57));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal57_tree);
            }

            char_literal58 = (pANTLR3_COMMON_TOKEN) MATCHT(27, &FOLLOW_27_in_blockStatement669);
            if  (HASEXCEPTION())
            {
                goto ruleblockStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal58_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal58));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal58_tree);
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleblockStatementEx; /* Prevent compiler warnings */
    ruleblockStatementEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end blockStatement */

/**
 * $ANTLR start whileStatement
 * MyGrammarTest.g:59:1: whileStatement : 'while' expr 'do' statement ;
 */
static MyGrammarTestParser_whileStatement_return
whileStatement(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_whileStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal59;
    pANTLR3_COMMON_TOKEN    string_literal61;
    MyGrammarTestParser_expr_return expr60;
    #undef	RETURN_TYPE_expr60
    #define	RETURN_TYPE_expr60 MyGrammarTestParser_expr_return

    MyGrammarTestParser_statement_return statement62;
    #undef	RETURN_TYPE_statement62
    #define	RETURN_TYPE_statement62 MyGrammarTestParser_statement_return

    pANTLR3_BASE_TREE string_literal59_tree;
    pANTLR3_BASE_TREE string_literal61_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal59       = NULL;
    string_literal61       = NULL;
    expr60.tree = NULL;

    statement62.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal59_tree   = NULL;
    string_literal61_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:59:16: ( 'while' expr 'do' statement )
        // MyGrammarTest.g:59:18: 'while' expr 'do' statement
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            string_literal59 = (pANTLR3_COMMON_TOKEN) MATCHT(51, &FOLLOW_51_in_whileStatement678);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal59_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal59));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal59_tree);
            }

            FOLLOWPUSH(FOLLOW_expr_in_whileStatement680);
            expr60=expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expr60.tree);

            string_literal61 = (pANTLR3_COMMON_TOKEN) MATCHT(36, &FOLLOW_36_in_whileStatement682);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal61_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal61));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal61_tree);
            }

            FOLLOWPUSH(FOLLOW_statement_in_whileStatement684);
            statement62=statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, statement62.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulewhileStatementEx; /* Prevent compiler warnings */
    rulewhileStatementEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end whileStatement */

/**
 * $ANTLR start doStatement
 * MyGrammarTest.g:61:1: doStatement : 'repeat' statement ( 'while' | 'until' ) expr ';' ;
 */
static MyGrammarTestParser_doStatement_return
doStatement(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_doStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal63;
    pANTLR3_COMMON_TOKEN    set65;
    pANTLR3_COMMON_TOKEN    char_literal67;
    MyGrammarTestParser_statement_return statement64;
    #undef	RETURN_TYPE_statement64
    #define	RETURN_TYPE_statement64 MyGrammarTestParser_statement_return

    MyGrammarTestParser_expr_return expr66;
    #undef	RETURN_TYPE_expr66
    #define	RETURN_TYPE_expr66 MyGrammarTestParser_expr_return

    pANTLR3_BASE_TREE string_literal63_tree;
    pANTLR3_BASE_TREE set65_tree;
    pANTLR3_BASE_TREE char_literal67_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal63       = NULL;
    set65       = NULL;
    char_literal67       = NULL;
    statement64.tree = NULL;

    expr66.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal63_tree   = NULL;
    set65_tree   = NULL;
    char_literal67_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:61:13: ( 'repeat' statement ( 'while' | 'until' ) expr ';' )
        // MyGrammarTest.g:61:15: 'repeat' statement ( 'while' | 'until' ) expr ';'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            string_literal63 = (pANTLR3_COMMON_TOKEN) MATCHT(44, &FOLLOW_44_in_doStatement693);
            if  (HASEXCEPTION())
            {
                goto ruledoStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal63_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal63));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal63_tree);
            }

            FOLLOWPUSH(FOLLOW_statement_in_doStatement695);
            statement64=statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledoStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, statement64.tree);

            set65=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == 49 || LA(1) == 51 )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set65))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruledoStatementEx;
            }


            FOLLOWPUSH(FOLLOW_expr_in_doStatement703);
            expr66=expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledoStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expr66.tree);

            char_literal67 = (pANTLR3_COMMON_TOKEN) MATCHT(27, &FOLLOW_27_in_doStatement705);
            if  (HASEXCEPTION())
            {
                goto ruledoStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal67_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal67));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal67_tree);
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruledoStatementEx; /* Prevent compiler warnings */
    ruledoStatementEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end doStatement */

/**
 * $ANTLR start breakStatement
 * MyGrammarTest.g:63:1: breakStatement : 'break' ';' ;
 */
static MyGrammarTestParser_breakStatement_return
breakStatement(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_breakStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal68;
    pANTLR3_COMMON_TOKEN    char_literal69;

    pANTLR3_BASE_TREE string_literal68_tree;
    pANTLR3_BASE_TREE char_literal69_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal68       = NULL;
    char_literal69       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal68_tree   = NULL;
    char_literal69_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:63:16: ( 'break' ';' )
        // MyGrammarTest.g:63:18: 'break' ';'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            string_literal68 = (pANTLR3_COMMON_TOKEN) MATCHT(33, &FOLLOW_33_in_breakStatement714);
            if  (HASEXCEPTION())
            {
                goto rulebreakStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal68_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal68));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal68_tree);
            }

            char_literal69 = (pANTLR3_COMMON_TOKEN) MATCHT(27, &FOLLOW_27_in_breakStatement716);
            if  (HASEXCEPTION())
            {
                goto rulebreakStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal69_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal69));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal69_tree);
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulebreakStatementEx; /* Prevent compiler warnings */
    rulebreakStatementEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end breakStatement */

/**
 * $ANTLR start expressionStatement
 * MyGrammarTest.g:65:1: expressionStatement : expr ';' ;
 */
static MyGrammarTestParser_expressionStatement_return
expressionStatement(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_expressionStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal71;
    MyGrammarTestParser_expr_return expr70;
    #undef	RETURN_TYPE_expr70
    #define	RETURN_TYPE_expr70 MyGrammarTestParser_expr_return

    pANTLR3_BASE_TREE char_literal71_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal71       = NULL;
    expr70.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal71_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:65:21: ( expr ';' )
        // MyGrammarTest.g:65:23: expr ';'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_expr_in_expressionStatement725);
            expr70=expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpressionStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expr70.tree);

            char_literal71 = (pANTLR3_COMMON_TOKEN) MATCHT(27, &FOLLOW_27_in_expressionStatement727);
            if  (HASEXCEPTION())
            {
                goto ruleexpressionStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal71_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal71));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal71_tree);
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexpressionStatementEx; /* Prevent compiler warnings */
    ruleexpressionStatementEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end expressionStatement */

/**
 * $ANTLR start expr
 * MyGrammarTest.g:71:1: expr : assignExpr ;
 */
static MyGrammarTestParser_expr_return
expr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_expr_return retval;


    pANTLR3_BASE_TREE root_0;

    MyGrammarTestParser_assignExpr_return assignExpr72;
    #undef	RETURN_TYPE_assignExpr72
    #define	RETURN_TYPE_assignExpr72 MyGrammarTestParser_assignExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    assignExpr72.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // MyGrammarTest.g:71:6: ( assignExpr )
        // MyGrammarTest.g:71:8: assignExpr
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_assignExpr_in_expr740);
            assignExpr72=assignExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexprEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, assignExpr72.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexprEx; /* Prevent compiler warnings */
    ruleexprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end expr */

/**
 * $ANTLR start assignExpr
 * MyGrammarTest.g:73:10: fragment assignExpr : ( binaryExpr ( '+=' | ':=' ) binaryExpr | binaryExpr );
 */
static MyGrammarTestParser_assignExpr_return
assignExpr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_assignExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set74;
    MyGrammarTestParser_binaryExpr_return binaryExpr73;
    #undef	RETURN_TYPE_binaryExpr73
    #define	RETURN_TYPE_binaryExpr73 MyGrammarTestParser_binaryExpr_return

    MyGrammarTestParser_binaryExpr_return binaryExpr75;
    #undef	RETURN_TYPE_binaryExpr75
    #define	RETURN_TYPE_binaryExpr75 MyGrammarTestParser_binaryExpr_return

    MyGrammarTestParser_binaryExpr_return binaryExpr76;
    #undef	RETURN_TYPE_binaryExpr76
    #define	RETURN_TYPE_binaryExpr76 MyGrammarTestParser_binaryExpr_return

    pANTLR3_BASE_TREE set74_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set74       = NULL;
    binaryExpr73.tree = NULL;

    binaryExpr75.tree = NULL;

    binaryExpr76.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set74_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  MyGrammarTest.g:73:21: ( binaryExpr ( '+=' | ':=' ) binaryExpr | binaryExpr )

            ANTLR3_UINT32 alt19;

            alt19=2;

            switch ( LA(1) )
            {
            case 15:
            case 23:
            	{
            		{
            		    int LA19_1 = LA(2);
            		    if ( (synpred38_MyGrammarTest(ctx)))
            		    {
            		        alt19=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt19=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 19;
            		        EXCEPTION->state        = 1;


            		        goto ruleassignExprEx;

            		    }
            		}
            	}
                break;
            case BITS_LITERAL:
            case BOOL_LITERAL:
            case CHAR:
            case DEC_LITERAL:
            case HEX_LITERAL:
            case STRING_LIT:
            	{
            		{
            		    int LA19_2 = LA(2);
            		    if ( (synpred38_MyGrammarTest(ctx)))
            		    {
            		        alt19=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt19=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 19;
            		        EXCEPTION->state        = 2;


            		        goto ruleassignExprEx;

            		    }
            		}
            	}
                break;
            case IDENTIFIER:
            	{
            		{
            		    int LA19_3 = LA(2);
            		    if ( (synpred38_MyGrammarTest(ctx)))
            		    {
            		        alt19=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt19=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 19;
            		        EXCEPTION->state        = 3;


            		        goto ruleassignExprEx;

            		    }
            		}
            	}
                break;
            case 17:
            	{
            		{
            		    int LA19_4 = LA(2);
            		    if ( (synpred38_MyGrammarTest(ctx)))
            		    {
            		        alt19=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt19=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 19;
            		        EXCEPTION->state        = 4;


            		        goto ruleassignExprEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 19;
                EXCEPTION->state        = 0;


                goto ruleassignExprEx;

            }

            switch (alt19)
            {
        	case 1:
        	    // MyGrammarTest.g:73:23: binaryExpr ( '+=' | ':=' ) binaryExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_binaryExpr_in_assignExpr751);
        	        binaryExpr73=binaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, binaryExpr73.tree);

        	        set74=(pANTLR3_COMMON_TOKEN)LT(1);

        	        if ( LA(1) == 21 || LA(1) == 26 )
        	        {
        	            CONSUME();
        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
        	            (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set74))
        	            );
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	            FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return retval;
        	            }

        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = NULL;

        	            goto ruleassignExprEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_binaryExpr_in_assignExpr761);
        	        binaryExpr75=binaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, binaryExpr75.tree);

        	    }
        	    break;
        	case 2:
        	    // MyGrammarTest.g:73:62: binaryExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_binaryExpr_in_assignExpr766);
        	        binaryExpr76=binaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, binaryExpr76.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleassignExprEx; /* Prevent compiler warnings */
    ruleassignExprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end assignExpr */

/**
 * $ANTLR start binaryExpr
 * MyGrammarTest.g:75:10: fragment binaryExpr : additiveExpr ;
 */
static MyGrammarTestParser_binaryExpr_return
binaryExpr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_binaryExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    MyGrammarTestParser_additiveExpr_return additiveExpr77;
    #undef	RETURN_TYPE_additiveExpr77
    #define	RETURN_TYPE_additiveExpr77 MyGrammarTestParser_additiveExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    additiveExpr77.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // MyGrammarTest.g:75:21: ( additiveExpr )
        // MyGrammarTest.g:75:23: additiveExpr
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_additiveExpr_in_binaryExpr776);
            additiveExpr77=additiveExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebinaryExprEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, additiveExpr77.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulebinaryExprEx; /* Prevent compiler warnings */
    rulebinaryExprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end binaryExpr */

/**
 * $ANTLR start additiveExpr
 * MyGrammarTest.g:77:10: fragment additiveExpr : ( multiplicativeExpr ( '+' | '-' ) multiplicativeExpr | multiplicativeExpr );
 */
static MyGrammarTestParser_additiveExpr_return
additiveExpr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_additiveExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set79;
    MyGrammarTestParser_multiplicativeExpr_return multiplicativeExpr78;
    #undef	RETURN_TYPE_multiplicativeExpr78
    #define	RETURN_TYPE_multiplicativeExpr78 MyGrammarTestParser_multiplicativeExpr_return

    MyGrammarTestParser_multiplicativeExpr_return multiplicativeExpr80;
    #undef	RETURN_TYPE_multiplicativeExpr80
    #define	RETURN_TYPE_multiplicativeExpr80 MyGrammarTestParser_multiplicativeExpr_return

    MyGrammarTestParser_multiplicativeExpr_return multiplicativeExpr81;
    #undef	RETURN_TYPE_multiplicativeExpr81
    #define	RETURN_TYPE_multiplicativeExpr81 MyGrammarTestParser_multiplicativeExpr_return

    pANTLR3_BASE_TREE set79_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set79       = NULL;
    multiplicativeExpr78.tree = NULL;

    multiplicativeExpr80.tree = NULL;

    multiplicativeExpr81.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set79_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  MyGrammarTest.g:77:23: ( multiplicativeExpr ( '+' | '-' ) multiplicativeExpr | multiplicativeExpr )

            ANTLR3_UINT32 alt20;

            alt20=2;

            switch ( LA(1) )
            {
            case 15:
            case 23:
            	{
            		{
            		    int LA20_1 = LA(2);
            		    if ( (synpred40_MyGrammarTest(ctx)))
            		    {
            		        alt20=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt20=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 20;
            		        EXCEPTION->state        = 1;


            		        goto ruleadditiveExprEx;

            		    }
            		}
            	}
                break;
            case BITS_LITERAL:
            case BOOL_LITERAL:
            case CHAR:
            case DEC_LITERAL:
            case HEX_LITERAL:
            case STRING_LIT:
            	{
            		{
            		    int LA20_2 = LA(2);
            		    if ( (synpred40_MyGrammarTest(ctx)))
            		    {
            		        alt20=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt20=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 20;
            		        EXCEPTION->state        = 2;


            		        goto ruleadditiveExprEx;

            		    }
            		}
            	}
                break;
            case IDENTIFIER:
            	{
            		{
            		    int LA20_3 = LA(2);
            		    if ( (synpred40_MyGrammarTest(ctx)))
            		    {
            		        alt20=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt20=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 20;
            		        EXCEPTION->state        = 3;


            		        goto ruleadditiveExprEx;

            		    }
            		}
            	}
                break;
            case 17:
            	{
            		{
            		    int LA20_4 = LA(2);
            		    if ( (synpred40_MyGrammarTest(ctx)))
            		    {
            		        alt20=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt20=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 20;
            		        EXCEPTION->state        = 4;


            		        goto ruleadditiveExprEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 20;
                EXCEPTION->state        = 0;


                goto ruleadditiveExprEx;

            }

            switch (alt20)
            {
        	case 1:
        	    // MyGrammarTest.g:77:25: multiplicativeExpr ( '+' | '-' ) multiplicativeExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_multiplicativeExpr_in_additiveExpr787);
        	        multiplicativeExpr78=multiplicativeExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleadditiveExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, multiplicativeExpr78.tree);

        	        set79=(pANTLR3_COMMON_TOKEN)LT(1);

        	        if ( LA(1) == 20 || LA(1) == 23 )
        	        {
        	            CONSUME();
        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
        	            (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set79))
        	            );
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	            FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return retval;
        	            }

        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = NULL;

        	            goto ruleadditiveExprEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_multiplicativeExpr_in_additiveExpr797);
        	        multiplicativeExpr80=multiplicativeExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleadditiveExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, multiplicativeExpr80.tree);

        	    }
        	    break;
        	case 2:
        	    // MyGrammarTest.g:77:78: multiplicativeExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_multiplicativeExpr_in_additiveExpr802);
        	        multiplicativeExpr81=multiplicativeExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleadditiveExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, multiplicativeExpr81.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleadditiveExprEx; /* Prevent compiler warnings */
    ruleadditiveExprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end additiveExpr */

/**
 * $ANTLR start multiplicativeExpr
 * MyGrammarTest.g:79:10: fragment multiplicativeExpr : ( unaryExpr ( '*' | '/' | '%' ) unaryExpr | unaryExpr );
 */
static MyGrammarTestParser_multiplicativeExpr_return
multiplicativeExpr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_multiplicativeExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set83;
    MyGrammarTestParser_unaryExpr_return unaryExpr82;
    #undef	RETURN_TYPE_unaryExpr82
    #define	RETURN_TYPE_unaryExpr82 MyGrammarTestParser_unaryExpr_return

    MyGrammarTestParser_unaryExpr_return unaryExpr84;
    #undef	RETURN_TYPE_unaryExpr84
    #define	RETURN_TYPE_unaryExpr84 MyGrammarTestParser_unaryExpr_return

    MyGrammarTestParser_unaryExpr_return unaryExpr85;
    #undef	RETURN_TYPE_unaryExpr85
    #define	RETURN_TYPE_unaryExpr85 MyGrammarTestParser_unaryExpr_return

    pANTLR3_BASE_TREE set83_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set83       = NULL;
    unaryExpr82.tree = NULL;

    unaryExpr84.tree = NULL;

    unaryExpr85.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set83_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  MyGrammarTest.g:79:29: ( unaryExpr ( '*' | '/' | '%' ) unaryExpr | unaryExpr )

            ANTLR3_UINT32 alt21;

            alt21=2;

            switch ( LA(1) )
            {
            case 15:
            case 23:
            	{
            		{
            		    int LA21_1 = LA(2);
            		    if ( (synpred43_MyGrammarTest(ctx)))
            		    {
            		        alt21=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt21=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 21;
            		        EXCEPTION->state        = 1;


            		        goto rulemultiplicativeExprEx;

            		    }
            		}
            	}
                break;
            case BITS_LITERAL:
            case BOOL_LITERAL:
            case CHAR:
            case DEC_LITERAL:
            case HEX_LITERAL:
            case STRING_LIT:
            	{
            		{
            		    int LA21_2 = LA(2);
            		    if ( (synpred43_MyGrammarTest(ctx)))
            		    {
            		        alt21=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt21=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 21;
            		        EXCEPTION->state        = 2;


            		        goto rulemultiplicativeExprEx;

            		    }
            		}
            	}
                break;
            case IDENTIFIER:
            	{
            		{
            		    int LA21_3 = LA(2);
            		    if ( (synpred43_MyGrammarTest(ctx)))
            		    {
            		        alt21=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt21=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 21;
            		        EXCEPTION->state        = 3;


            		        goto rulemultiplicativeExprEx;

            		    }
            		}
            	}
                break;
            case 17:
            	{
            		{
            		    int LA21_4 = LA(2);
            		    if ( (synpred43_MyGrammarTest(ctx)))
            		    {
            		        alt21=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt21=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 21;
            		        EXCEPTION->state        = 4;


            		        goto rulemultiplicativeExprEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 21;
                EXCEPTION->state        = 0;


                goto rulemultiplicativeExprEx;

            }

            switch (alt21)
            {
        	case 1:
        	    // MyGrammarTest.g:79:31: unaryExpr ( '*' | '/' | '%' ) unaryExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_unaryExpr_in_multiplicativeExpr813);
        	        unaryExpr82=unaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemultiplicativeExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, unaryExpr82.tree);

        	        set83=(pANTLR3_COMMON_TOKEN)LT(1);

        	        if ( LA(1) == 16 || LA(1) == 19 || LA(1) == 24 )
        	        {
        	            CONSUME();
        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
        	            (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set83))
        	            );
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	            FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return retval;
        	            }

        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = NULL;

        	            goto rulemultiplicativeExprEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_unaryExpr_in_multiplicativeExpr827);
        	        unaryExpr84=unaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemultiplicativeExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, unaryExpr84.tree);

        	    }
        	    break;
        	case 2:
        	    // MyGrammarTest.g:79:71: unaryExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_unaryExpr_in_multiplicativeExpr831);
        	        unaryExpr85=unaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemultiplicativeExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, unaryExpr85.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulemultiplicativeExprEx; /* Prevent compiler warnings */
    rulemultiplicativeExprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end multiplicativeExpr */

/**
 * $ANTLR start unaryExpr
 * MyGrammarTest.g:81:10: fragment unaryExpr : ( unOp unaryExpr | primaryExpr );
 */
static MyGrammarTestParser_unaryExpr_return
unaryExpr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_unaryExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    MyGrammarTestParser_unOp_return unOp86;
    #undef	RETURN_TYPE_unOp86
    #define	RETURN_TYPE_unOp86 MyGrammarTestParser_unOp_return

    MyGrammarTestParser_unaryExpr_return unaryExpr87;
    #undef	RETURN_TYPE_unaryExpr87
    #define	RETURN_TYPE_unaryExpr87 MyGrammarTestParser_unaryExpr_return

    MyGrammarTestParser_primaryExpr_return primaryExpr88;
    #undef	RETURN_TYPE_primaryExpr88
    #define	RETURN_TYPE_primaryExpr88 MyGrammarTestParser_primaryExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    unOp86.tree = NULL;

    unaryExpr87.tree = NULL;

    primaryExpr88.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  MyGrammarTest.g:81:20: ( unOp unaryExpr | primaryExpr )

            ANTLR3_UINT32 alt22;

            alt22=2;

            switch ( LA(1) )
            {
            case 15:
            case 23:
            	{
            		alt22=1;
            	}
                break;
            case BITS_LITERAL:
            case BOOL_LITERAL:
            case CHAR:
            case DEC_LITERAL:
            case HEX_LITERAL:
            case IDENTIFIER:
            case STRING_LIT:
            case 17:
            	{
            		alt22=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 0;


                goto ruleunaryExprEx;

            }

            switch (alt22)
            {
        	case 1:
        	    // MyGrammarTest.g:81:22: unOp unaryExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_unOp_in_unaryExpr842);
        	        unOp86=unOp(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, unOp86.tree);

        	        FOLLOWPUSH(FOLLOW_unaryExpr_in_unaryExpr844);
        	        unaryExpr87=unaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, unaryExpr87.tree);

        	    }
        	    break;
        	case 2:
        	    // MyGrammarTest.g:81:39: primaryExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_primaryExpr_in_unaryExpr848);
        	        primaryExpr88=primaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, primaryExpr88.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleunaryExprEx; /* Prevent compiler warnings */
    ruleunaryExprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end unaryExpr */

/**
 * $ANTLR start primaryExpr
 * MyGrammarTest.g:83:10: fragment primaryExpr : ( literal | IDENTIFIER | '(' expr ')' | call | indexer );
 */
static MyGrammarTestParser_primaryExpr_return
primaryExpr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_primaryExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER90;
    pANTLR3_COMMON_TOKEN    char_literal91;
    pANTLR3_COMMON_TOKEN    char_literal93;
    MyGrammarTestParser_literal_return literal89;
    #undef	RETURN_TYPE_literal89
    #define	RETURN_TYPE_literal89 MyGrammarTestParser_literal_return

    MyGrammarTestParser_expr_return expr92;
    #undef	RETURN_TYPE_expr92
    #define	RETURN_TYPE_expr92 MyGrammarTestParser_expr_return

    MyGrammarTestParser_call_return call94;
    #undef	RETURN_TYPE_call94
    #define	RETURN_TYPE_call94 MyGrammarTestParser_call_return

    MyGrammarTestParser_indexer_return indexer95;
    #undef	RETURN_TYPE_indexer95
    #define	RETURN_TYPE_indexer95 MyGrammarTestParser_indexer_return

    pANTLR3_BASE_TREE IDENTIFIER90_tree;
    pANTLR3_BASE_TREE char_literal91_tree;
    pANTLR3_BASE_TREE char_literal93_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    IDENTIFIER90       = NULL;
    char_literal91       = NULL;
    char_literal93       = NULL;
    literal89.tree = NULL;

    expr92.tree = NULL;

    call94.tree = NULL;

    indexer95.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IDENTIFIER90_tree   = NULL;
    char_literal91_tree   = NULL;
    char_literal93_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  MyGrammarTest.g:84:5: ( literal | IDENTIFIER | '(' expr ')' | call | indexer )

            ANTLR3_UINT32 alt23;

            alt23=5;

            switch ( LA(1) )
            {
            case BITS_LITERAL:
            case BOOL_LITERAL:
            case CHAR:
            case DEC_LITERAL:
            case HEX_LITERAL:
            case STRING_LIT:
            	{
            		alt23=1;
            	}
                break;
            case IDENTIFIER:
            	{
            		switch ( LA(2) )
            		{
            		case 17:
            			{
            				alt23=4;
            			}
            		    break;
            		case 28:
            			{
            				alt23=5;
            			}
            		    break;
            		case EOF:
            		case 16:
            		case 18:
            		case 19:
            		case 20:
            		case 21:
            		case 22:
            		case 23:
            		case 24:
            		case 26:
            		case 27:
            		case 29:
            		case 36:
            		case 46:
            			{
            				alt23=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return retval;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 23;
            		    EXCEPTION->state        = 2;


            		    goto ruleprimaryExprEx;

            		}

            	}
                break;
            case 17:
            	{
            		alt23=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 23;
                EXCEPTION->state        = 0;


                goto ruleprimaryExprEx;

            }

            switch (alt23)
            {
        	case 1:
        	    // MyGrammarTest.g:84:7: literal
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_literal_in_primaryExpr863);
        	        literal89=literal(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, literal89.tree);

        	    }
        	    break;
        	case 2:
        	    // MyGrammarTest.g:85:7: IDENTIFIER
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        IDENTIFIER90 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_primaryExpr899);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) {
        	        IDENTIFIER90_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER90));
        	        ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER90_tree);
        	        }

        	    }
        	    break;
        	case 3:
        	    // MyGrammarTest.g:86:7: '(' expr ')'
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        char_literal91 = (pANTLR3_COMMON_TOKEN) MATCHT(17, &FOLLOW_17_in_primaryExpr932);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) {
        	        char_literal91_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal91));
        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal91_tree);
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_primaryExpr934);
        	        expr92=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expr92.tree);

        	        char_literal93 = (pANTLR3_COMMON_TOKEN) MATCHT(18, &FOLLOW_18_in_primaryExpr936);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) {
        	        char_literal93_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal93));
        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal93_tree);
        	        }

        	    }
        	    break;
        	case 4:
        	    // MyGrammarTest.g:87:7: call
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_call_in_primaryExpr968);
        	        call94=call(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, call94.tree);

        	    }
        	    break;
        	case 5:
        	    // MyGrammarTest.g:88:7: indexer
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_indexer_in_primaryExpr1007);
        	        indexer95=indexer(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, indexer95.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleprimaryExprEx; /* Prevent compiler warnings */
    ruleprimaryExprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end primaryExpr */

/**
 * $ANTLR start call
 * MyGrammarTest.g:91:1: call : IDENTIFIER '(' list_expr ')' ;
 */
static MyGrammarTestParser_call_return
call(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_call_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER96;
    pANTLR3_COMMON_TOKEN    char_literal97;
    pANTLR3_COMMON_TOKEN    char_literal99;
    MyGrammarTestParser_list_expr_return list_expr98;
    #undef	RETURN_TYPE_list_expr98
    #define	RETURN_TYPE_list_expr98 MyGrammarTestParser_list_expr_return

    pANTLR3_BASE_TREE IDENTIFIER96_tree;
    pANTLR3_BASE_TREE char_literal97_tree;
    pANTLR3_BASE_TREE char_literal99_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    IDENTIFIER96       = NULL;
    char_literal97       = NULL;
    char_literal99       = NULL;
    list_expr98.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IDENTIFIER96_tree   = NULL;
    char_literal97_tree   = NULL;
    char_literal99_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:91:6: ( IDENTIFIER '(' list_expr ')' )
        // MyGrammarTest.g:91:8: IDENTIFIER '(' list_expr ')'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            IDENTIFIER96 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_call1048);
            if  (HASEXCEPTION())
            {
                goto rulecallEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            IDENTIFIER96_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER96));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER96_tree);
            }

            char_literal97 = (pANTLR3_COMMON_TOKEN) MATCHT(17, &FOLLOW_17_in_call1050);
            if  (HASEXCEPTION())
            {
                goto rulecallEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal97_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal97));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal97_tree);
            }

            FOLLOWPUSH(FOLLOW_list_expr_in_call1052);
            list_expr98=list_expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecallEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, list_expr98.tree);

            char_literal99 = (pANTLR3_COMMON_TOKEN) MATCHT(18, &FOLLOW_18_in_call1054);
            if  (HASEXCEPTION())
            {
                goto rulecallEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal99_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal99));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal99_tree);
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulecallEx; /* Prevent compiler warnings */
    rulecallEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end call */

/**
 * $ANTLR start indexer
 * MyGrammarTest.g:93:10: fragment indexer : IDENTIFIER '[' list_expr ']' ;
 */
static MyGrammarTestParser_indexer_return
indexer(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_indexer_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER100;
    pANTLR3_COMMON_TOKEN    char_literal101;
    pANTLR3_COMMON_TOKEN    char_literal103;
    MyGrammarTestParser_list_expr_return list_expr102;
    #undef	RETURN_TYPE_list_expr102
    #define	RETURN_TYPE_list_expr102 MyGrammarTestParser_list_expr_return

    pANTLR3_BASE_TREE IDENTIFIER100_tree;
    pANTLR3_BASE_TREE char_literal101_tree;
    pANTLR3_BASE_TREE char_literal103_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    IDENTIFIER100       = NULL;
    char_literal101       = NULL;
    char_literal103       = NULL;
    list_expr102.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IDENTIFIER100_tree   = NULL;
    char_literal101_tree   = NULL;
    char_literal103_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:93:18: ( IDENTIFIER '[' list_expr ']' )
        // MyGrammarTest.g:93:20: IDENTIFIER '[' list_expr ']'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            IDENTIFIER100 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_indexer1065);
            if  (HASEXCEPTION())
            {
                goto ruleindexerEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            IDENTIFIER100_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER100));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER100_tree);
            }

            char_literal101 = (pANTLR3_COMMON_TOKEN) MATCHT(28, &FOLLOW_28_in_indexer1067);
            if  (HASEXCEPTION())
            {
                goto ruleindexerEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal101_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal101));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal101_tree);
            }

            FOLLOWPUSH(FOLLOW_list_expr_in_indexer1069);
            list_expr102=list_expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleindexerEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, list_expr102.tree);

            char_literal103 = (pANTLR3_COMMON_TOKEN) MATCHT(29, &FOLLOW_29_in_indexer1071);
            if  (HASEXCEPTION())
            {
                goto ruleindexerEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal103_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal103));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal103_tree);
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleindexerEx; /* Prevent compiler warnings */
    ruleindexerEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end indexer */

/**
 * $ANTLR start literal
 * MyGrammarTest.g:95:10: fragment literal : ( BOOL_LITERAL | STRING_LIT | CHAR | HEX_LITERAL | BITS_LITERAL | DEC_LITERAL );
 */
static MyGrammarTestParser_literal_return
literal(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_literal_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set104;

    pANTLR3_BASE_TREE set104_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set104       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set104_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:95:18: ( BOOL_LITERAL | STRING_LIT | CHAR | HEX_LITERAL | BITS_LITERAL | DEC_LITERAL )
        // MyGrammarTest.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set104=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( ((LA(1) >= BITS_LITERAL) && (LA(1) <= DEC_LITERAL)) || LA(1) == HEX_LITERAL || LA(1) == STRING_LIT )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set104))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleliteralEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleliteralEx; /* Prevent compiler warnings */
    ruleliteralEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end literal */

/**
 * $ANTLR start list_expr
 * MyGrammarTest.g:97:1: list_expr : ( expr ( ',' expr )* )? ;
 */
static MyGrammarTestParser_list_expr_return
list_expr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_list_expr_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal106;
    MyGrammarTestParser_expr_return expr105;
    #undef	RETURN_TYPE_expr105
    #define	RETURN_TYPE_expr105 MyGrammarTestParser_expr_return

    MyGrammarTestParser_expr_return expr107;
    #undef	RETURN_TYPE_expr107
    #define	RETURN_TYPE_expr107 MyGrammarTestParser_expr_return

    pANTLR3_BASE_TREE char_literal106_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal106       = NULL;
    expr105.tree = NULL;

    expr107.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal106_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:97:11: ( ( expr ( ',' expr )* )? )
        // MyGrammarTest.g:97:13: ( expr ( ',' expr )* )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // MyGrammarTest.g:97:13: ( expr ( ',' expr )* )?
            {
                int alt25=2;
                switch ( LA(1) )
                {
                    case BITS_LITERAL:
                    case BOOL_LITERAL:
                    case CHAR:
                    case DEC_LITERAL:
                    case HEX_LITERAL:
                    case IDENTIFIER:
                    case STRING_LIT:
                    case 15:
                    case 17:
                    case 23:
                    	{
                    		alt25=1;
                    	}
                        break;
                }

                switch (alt25)
                {
            	case 1:
            	    // MyGrammarTest.g:97:14: expr ( ',' expr )*
            	    {
            	        FOLLOWPUSH(FOLLOW_expr_in_list_expr1112);
            	        expr105=expr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelist_exprEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expr105.tree);

            	        // MyGrammarTest.g:97:19: ( ',' expr )*

            	        for (;;)
            	        {
            	            int alt24=2;
            	            switch ( LA(1) )
            	            {
            	            case 22:
            	            	{
            	            		alt24=1;
            	            	}
            	                break;

            	            }

            	            switch (alt24)
            	            {
            	        	case 1:
            	        	    // MyGrammarTest.g:97:20: ',' expr
            	        	    {
            	        	        char_literal106 = (pANTLR3_COMMON_TOKEN) MATCHT(22, &FOLLOW_22_in_list_expr1115);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelist_exprEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) {
            	        	        char_literal106_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal106));
            	        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal106_tree);
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_expr_in_list_expr1117);
            	        	        expr107=expr(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelist_exprEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expr107.tree);

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop24;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop24: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulelist_exprEx; /* Prevent compiler warnings */
    rulelist_exprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end list_expr */

/**
 * $ANTLR start unOp
 * MyGrammarTest.g:99:1: unOp : ( '-' | '!' ) ;
 */
static MyGrammarTestParser_unOp_return
unOp(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_unOp_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set108;

    pANTLR3_BASE_TREE set108_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set108       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set108_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:99:6: ( ( '-' | '!' ) )
        // MyGrammarTest.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set108=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == 15 || LA(1) == 23 )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set108))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleunOpEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleunOpEx; /* Prevent compiler warnings */
    ruleunOpEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end unOp */

// $ANTLR start synpred34_MyGrammarTest
static void synpred34_MyGrammarTest_fragment(pMyGrammarTestParser ctx )
{
    // MyGrammarTest.g:55:43: ( 'else' statement )
    // MyGrammarTest.g:55:43: 'else' statement
    {
         MATCHT(37, &FOLLOW_37_in_synpred34_MyGrammarTest649);
        if  (HASEXCEPTION())
        {
            goto rulesynpred34_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        FOLLOWPUSH(FOLLOW_statement_in_synpred34_MyGrammarTest651);
        statement(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred34_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred34_MyGrammarTestEx; /* Prevent compiler warnings */
rulesynpred34_MyGrammarTestEx: ;

}
// $ANTLR end synpred34_MyGrammarTest

// $ANTLR start synpred38_MyGrammarTest
static void synpred38_MyGrammarTest_fragment(pMyGrammarTestParser ctx )
{
    // MyGrammarTest.g:73:23: ( binaryExpr ( '+=' | ':=' ) binaryExpr )
    // MyGrammarTest.g:73:23: binaryExpr ( '+=' | ':=' ) binaryExpr
    {
        FOLLOWPUSH(FOLLOW_binaryExpr_in_synpred38_MyGrammarTest751);
        binaryExpr(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred38_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        if ( LA(1) == 21 || LA(1) == 26 )
        {
            CONSUME();
            PERRORRECOVERY=ANTLR3_FALSE;
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            EXCEPTION->expectingSet = NULL;

            goto rulesynpred38_MyGrammarTestEx;
        }


        FOLLOWPUSH(FOLLOW_binaryExpr_in_synpred38_MyGrammarTest761);
        binaryExpr(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred38_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred38_MyGrammarTestEx; /* Prevent compiler warnings */
rulesynpred38_MyGrammarTestEx: ;

}
// $ANTLR end synpred38_MyGrammarTest

// $ANTLR start synpred40_MyGrammarTest
static void synpred40_MyGrammarTest_fragment(pMyGrammarTestParser ctx )
{
    // MyGrammarTest.g:77:25: ( multiplicativeExpr ( '+' | '-' ) multiplicativeExpr )
    // MyGrammarTest.g:77:25: multiplicativeExpr ( '+' | '-' ) multiplicativeExpr
    {
        FOLLOWPUSH(FOLLOW_multiplicativeExpr_in_synpred40_MyGrammarTest787);
        multiplicativeExpr(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred40_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        if ( LA(1) == 20 || LA(1) == 23 )
        {
            CONSUME();
            PERRORRECOVERY=ANTLR3_FALSE;
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            EXCEPTION->expectingSet = NULL;

            goto rulesynpred40_MyGrammarTestEx;
        }


        FOLLOWPUSH(FOLLOW_multiplicativeExpr_in_synpred40_MyGrammarTest797);
        multiplicativeExpr(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred40_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred40_MyGrammarTestEx; /* Prevent compiler warnings */
rulesynpred40_MyGrammarTestEx: ;

}
// $ANTLR end synpred40_MyGrammarTest

// $ANTLR start synpred43_MyGrammarTest
static void synpred43_MyGrammarTest_fragment(pMyGrammarTestParser ctx )
{
    // MyGrammarTest.g:79:31: ( unaryExpr ( '*' | '/' | '%' ) unaryExpr )
    // MyGrammarTest.g:79:31: unaryExpr ( '*' | '/' | '%' ) unaryExpr
    {
        FOLLOWPUSH(FOLLOW_unaryExpr_in_synpred43_MyGrammarTest813);
        unaryExpr(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred43_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        if ( LA(1) == 16 || LA(1) == 19 || LA(1) == 24 )
        {
            CONSUME();
            PERRORRECOVERY=ANTLR3_FALSE;
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            EXCEPTION->expectingSet = NULL;

            goto rulesynpred43_MyGrammarTestEx;
        }


        FOLLOWPUSH(FOLLOW_unaryExpr_in_synpred43_MyGrammarTest827);
        unaryExpr(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred43_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred43_MyGrammarTestEx; /* Prevent compiler warnings */
rulesynpred43_MyGrammarTestEx: ;

}
// $ANTLR end synpred43_MyGrammarTest
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred38_MyGrammarTest(pMyGrammarTestParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred38_MyGrammarTest_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred40_MyGrammarTest(pMyGrammarTestParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred40_MyGrammarTest_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred43_MyGrammarTest(pMyGrammarTestParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred43_MyGrammarTest_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred34_MyGrammarTest(pMyGrammarTestParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred34_MyGrammarTest_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
