/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : MyGrammarTest.g
 *     -                            On : 2024-10-11 01:50:23
 *     -                for the parser : MyGrammarTestParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "MyGrammarTestParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pMyGrammarTestParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pMyGrammarTestParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pMyGrammarTestParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pMyGrammarTestParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   MyGrammarTestParserTokenNames[74+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ARGS",
        (pANTLR3_UINT8) "Array",
        (pANTLR3_UINT8) "ArrayType",
        (pANTLR3_UINT8) "BITS_LITERAL",
        (pANTLR3_UINT8) "BLOCK",
        (pANTLR3_UINT8) "BOOL_LITERAL",
        (pANTLR3_UINT8) "BREAKSTATEMENT",
        (pANTLR3_UINT8) "BUILTIN",
        (pANTLR3_UINT8) "BodySig",
        (pANTLR3_UINT8) "BuiltinType",
        (pANTLR3_UINT8) "CHAR",
        (pANTLR3_UINT8) "CUSTOM",
        (pANTLR3_UINT8) "Call",
        (pANTLR3_UINT8) "CustomType",
        (pANTLR3_UINT8) "DEC_LITERAL",
        (pANTLR3_UINT8) "ESC_SEQ",
        (pANTLR3_UINT8) "EXPR",
        (pANTLR3_UINT8) "EXPRESSION",
        (pANTLR3_UINT8) "FuncDef",
        (pANTLR3_UINT8) "FuncSignature",
        (pANTLR3_UINT8) "HEX_DIGIT",
        (pANTLR3_UINT8) "HEX_LITERAL",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "IFSTATEMENT",
        (pANTLR3_UINT8) "LINE_COMMENT",
        (pANTLR3_UINT8) "LOOPSTATEMENT",
        (pANTLR3_UINT8) "ListArg",
        (pANTLR3_UINT8) "ListArgDefs",
        (pANTLR3_UINT8) "ListIdentifier",
        (pANTLR3_UINT8) "ST",
        (pANTLR3_UINT8) "STRING_LIT",
        (pANTLR3_UINT8) "Source",
        (pANTLR3_UINT8) "SourceItem",
        (pANTLR3_UINT8) "Statement",
        (pANTLR3_UINT8) "TypeRef",
        (pANTLR3_UINT8) "Vars",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "'!'",
        (pANTLR3_UINT8) "'%'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "'+='",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'/'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "':='",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'array'",
        (pANTLR3_UINT8) "'begin'",
        (pANTLR3_UINT8) "'bool'",
        (pANTLR3_UINT8) "'break'",
        (pANTLR3_UINT8) "'byte'",
        (pANTLR3_UINT8) "'char'",
        (pANTLR3_UINT8) "'do'",
        (pANTLR3_UINT8) "'else'",
        (pANTLR3_UINT8) "'end'",
        (pANTLR3_UINT8) "'if'",
        (pANTLR3_UINT8) "'int'",
        (pANTLR3_UINT8) "'long'",
        (pANTLR3_UINT8) "'method'",
        (pANTLR3_UINT8) "'of'",
        (pANTLR3_UINT8) "'repeat'",
        (pANTLR3_UINT8) "'string'",
        (pANTLR3_UINT8) "'then'",
        (pANTLR3_UINT8) "'uint'",
        (pANTLR3_UINT8) "'ulong'",
        (pANTLR3_UINT8) "'until'",
        (pANTLR3_UINT8) "'var'",
        (pANTLR3_UINT8) "'while'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 MyGrammarTestParser_source_return
	source    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_sourceItem_return
	sourceItem    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_funcDef_return
	funcDef    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_body_return
	body    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_list_identifier_return
	list_identifier    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_typeRef_return
	typeRef    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_builtin_return
	builtin    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_custom_return
	custom    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_array_return
	array    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_funcSignature_return
	funcSignature    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_list_argDef_return
	list_argDef    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_argDef_return
	argDef    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_typeRefDef_return
	typeRefDef    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_statement_return
	statement    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_ifStatement_return
	ifStatement    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_blockStatement_return
	blockStatement    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_whileStatement_return
	whileStatement    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_doStatement_return
	doStatement    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_breakStatement_return
	breakStatement    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_expressionStatement_return
	expressionStatement    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_expr_return
	expr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_assignExpr_return
	assignExpr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_binaryExpr_return
	binaryExpr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_additiveExpr_return
	additiveExpr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_multiplicativeExpr_return
	multiplicativeExpr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_unaryExpr_return
	unaryExpr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_primaryExpr_return
	primaryExpr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_call_return
	call    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_indexer_return
	indexer    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_literal_return
	literal    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_list_expr_return
	list_expr    (pMyGrammarTestParser ctx);
static 
 MyGrammarTestParser_unOp_return
	unOp    (pMyGrammarTestParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred27_MyGrammarTest    (pMyGrammarTestParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred31_MyGrammarTest    (pMyGrammarTestParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred33_MyGrammarTest    (pMyGrammarTestParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred36_MyGrammarTest    (pMyGrammarTestParser ctx);
static void	MyGrammarTestParserFree(pMyGrammarTestParser ctx);
static void     MyGrammarTestParserReset (pMyGrammarTestParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "MyGrammarTest.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new MyGrammarTestParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pMyGrammarTestParser
MyGrammarTestParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return MyGrammarTestParserNewSSD(instream, NULL);
}

/** \brief Create a new MyGrammarTestParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pMyGrammarTestParser
MyGrammarTestParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pMyGrammarTestParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pMyGrammarTestParser) ANTLR3_CALLOC(1, sizeof(MyGrammarTestParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in MyGrammarTestParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our MyGrammarTestParser interface
     */
    ctx->source	= source;
    ctx->sourceItem	= sourceItem;
    ctx->funcDef	= funcDef;
    ctx->body	= body;
    ctx->list_identifier	= list_identifier;
    ctx->typeRef	= typeRef;
    ctx->builtin	= builtin;
    ctx->custom	= custom;
    ctx->array	= array;
    ctx->funcSignature	= funcSignature;
    ctx->list_argDef	= list_argDef;
    ctx->argDef	= argDef;
    ctx->typeRefDef	= typeRefDef;
    ctx->statement	= statement;
    ctx->ifStatement	= ifStatement;
    ctx->blockStatement	= blockStatement;
    ctx->whileStatement	= whileStatement;
    ctx->doStatement	= doStatement;
    ctx->breakStatement	= breakStatement;
    ctx->expressionStatement	= expressionStatement;
    ctx->expr	= expr;
    ctx->assignExpr	= assignExpr;
    ctx->binaryExpr	= binaryExpr;
    ctx->additiveExpr	= additiveExpr;
    ctx->multiplicativeExpr	= multiplicativeExpr;
    ctx->unaryExpr	= unaryExpr;
    ctx->primaryExpr	= primaryExpr;
    ctx->call	= call;
    ctx->indexer	= indexer;
    ctx->literal	= literal;
    ctx->list_expr	= list_expr;
    ctx->unOp	= unOp;
    ctx->synpred27_MyGrammarTest	= synpred27_MyGrammarTest;
    ctx->synpred31_MyGrammarTest	= synpred31_MyGrammarTest;
    ctx->synpred33_MyGrammarTest	= synpred33_MyGrammarTest;
    ctx->synpred36_MyGrammarTest	= synpred36_MyGrammarTest;
    ctx->free			= MyGrammarTestParserFree;
    ctx->reset			= MyGrammarTestParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */
ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);

ctx->vectors	= antlr3VectorFactoryNew(0);
    /* Install the token table
     */
    PSRSTATE->tokenNames   = MyGrammarTestParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
MyGrammarTestParserReset (pMyGrammarTestParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 MyGrammarTestParserFree(pMyGrammarTestParser ctx)
 {
    /* Free any scope memory
     */

ctx->vectors->close(ctx->vectors);
/* We created the adaptor so we must free it
 */
ADAPTOR->free(ADAPTOR);
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return MyGrammarTestParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sourceItem_in_source184  */
static	ANTLR3_BITWORD FOLLOW_sourceItem_in_source184_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_sourceItem_in_source184	= { FOLLOW_sourceItem_in_source184_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_funcDef_in_sourceItem202  */
static	ANTLR3_BITWORD FOLLOW_funcDef_in_sourceItem202_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_funcDef_in_sourceItem202	= { FOLLOW_funcDef_in_sourceItem202_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_68_in_funcDef219  */
static	ANTLR3_BITWORD FOLLOW_68_in_funcDef219_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_68_in_funcDef219	= { FOLLOW_68_in_funcDef219_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_funcSignature_in_funcDef221  */
static	ANTLR3_BITWORD FOLLOW_funcSignature_in_funcDef221_bits[]	= { ANTLR3_UINT64_LIT(0x0220000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_funcSignature_in_funcDef221	= { FOLLOW_funcSignature_in_funcDef221_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_body_in_funcDef225  */
static	ANTLR3_BITWORD FOLLOW_body_in_funcDef225_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_body_in_funcDef225	= { FOLLOW_body_in_funcDef225_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_53_in_funcDef229  */
static	ANTLR3_BITWORD FOLLOW_53_in_funcDef229_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_53_in_funcDef229	= { FOLLOW_53_in_funcDef229_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_76_in_body253  */
static	ANTLR3_BITWORD FOLLOW_76_in_body253_bits[]	= { ANTLR3_UINT64_LIT(0x0228000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_76_in_body253	= { FOLLOW_76_in_body253_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_identifier_in_body257  */
static	ANTLR3_BITWORD FOLLOW_list_identifier_in_body257_bits[]	= { ANTLR3_UINT64_LIT(0x0028000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_list_identifier_in_body257	= { FOLLOW_list_identifier_in_body257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_51_in_body260  */
static	ANTLR3_BITWORD FOLLOW_51_in_body260_bits[]	= { ANTLR3_UINT64_LIT(0x3500000004000000), ANTLR3_UINT64_LIT(0x000000000000068C) };
static  ANTLR3_BITSET_LIST FOLLOW_51_in_body260	= { FOLLOW_51_in_body260_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeRef_in_body262  */
static	ANTLR3_BITWORD FOLLOW_typeRef_in_body262_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_typeRef_in_body262	= { FOLLOW_typeRef_in_body262_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_53_in_body266  */
static	ANTLR3_BITWORD FOLLOW_53_in_body266_bits[]	= { ANTLR3_UINT64_LIT(0x0228000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_53_in_body266	= { FOLLOW_53_in_body266_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_blockStatement_in_body274  */
static	ANTLR3_BITWORD FOLLOW_blockStatement_in_body274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_blockStatement_in_body274	= { FOLLOW_blockStatement_in_body274_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_list_identifier303  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_list_identifier303_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_list_identifier303	= { FOLLOW_IDENTIFIER_in_list_identifier303_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_48_in_list_identifier306  */
static	ANTLR3_BITWORD FOLLOW_48_in_list_identifier306_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_48_in_list_identifier306	= { FOLLOW_48_in_list_identifier306_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_list_identifier308  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_list_identifier308_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_list_identifier308	= { FOLLOW_IDENTIFIER_in_list_identifier308_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_builtin_in_typeRef330  */
static	ANTLR3_BITWORD FOLLOW_builtin_in_typeRef330_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_builtin_in_typeRef330	= { FOLLOW_builtin_in_typeRef330_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_custom_in_typeRef346  */
static	ANTLR3_BITWORD FOLLOW_custom_in_typeRef346_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_custom_in_typeRef346	= { FOLLOW_custom_in_typeRef346_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_array_in_typeRef362  */
static	ANTLR3_BITWORD FOLLOW_array_in_typeRef362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_array_in_typeRef362	= { FOLLOW_array_in_typeRef362_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_custom458  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_custom458_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_custom458	= { FOLLOW_IDENTIFIER_in_custom458_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_array468  */
static	ANTLR3_BITWORD FOLLOW_56_in_array468_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_56_in_array468	= { FOLLOW_56_in_array468_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_array470  */
static	ANTLR3_BITWORD FOLLOW_54_in_array470_bits[]	= { ANTLR3_UINT64_LIT(0x0081000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_54_in_array470	= { FOLLOW_54_in_array470_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_48_in_array473  */
static	ANTLR3_BITWORD FOLLOW_48_in_array473_bits[]	= { ANTLR3_UINT64_LIT(0x0081000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_48_in_array473	= { FOLLOW_48_in_array473_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_55_in_array477  */
static	ANTLR3_BITWORD FOLLOW_55_in_array477_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_55_in_array477	= { FOLLOW_55_in_array477_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_69_in_array479  */
static	ANTLR3_BITWORD FOLLOW_69_in_array479_bits[]	= { ANTLR3_UINT64_LIT(0x3500000004000000), ANTLR3_UINT64_LIT(0x000000000000068C) };
static  ANTLR3_BITSET_LIST FOLLOW_69_in_array479	= { FOLLOW_69_in_array479_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeRef_in_array481  */
static	ANTLR3_BITWORD FOLLOW_typeRef_in_array481_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typeRef_in_array481	= { FOLLOW_typeRef_in_array481_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_funcSignature500  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_funcSignature500_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_funcSignature500	= { FOLLOW_IDENTIFIER_in_funcSignature500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_funcSignature502  */
static	ANTLR3_BITWORD FOLLOW_43_in_funcSignature502_bits[]	= { ANTLR3_UINT64_LIT(0x0000100004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_funcSignature502	= { FOLLOW_43_in_funcSignature502_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_argDef_in_funcSignature504  */
static	ANTLR3_BITWORD FOLLOW_list_argDef_in_funcSignature504_bits[]	= { ANTLR3_UINT64_LIT(0x0000100000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_list_argDef_in_funcSignature504	= { FOLLOW_list_argDef_in_funcSignature504_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_funcSignature506  */
static	ANTLR3_BITWORD FOLLOW_44_in_funcSignature506_bits[]	= { ANTLR3_UINT64_LIT(0x0008000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_44_in_funcSignature506	= { FOLLOW_44_in_funcSignature506_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeRefDef_in_funcSignature508  */
static	ANTLR3_BITWORD FOLLOW_typeRefDef_in_funcSignature508_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typeRefDef_in_funcSignature508	= { FOLLOW_typeRefDef_in_funcSignature508_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argDef_in_list_argDef537  */
static	ANTLR3_BITWORD FOLLOW_argDef_in_list_argDef537_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_argDef_in_list_argDef537	= { FOLLOW_argDef_in_list_argDef537_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_48_in_list_argDef540  */
static	ANTLR3_BITWORD FOLLOW_48_in_list_argDef540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_48_in_list_argDef540	= { FOLLOW_48_in_list_argDef540_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argDef_in_list_argDef542  */
static	ANTLR3_BITWORD FOLLOW_argDef_in_list_argDef542_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_argDef_in_list_argDef542	= { FOLLOW_argDef_in_list_argDef542_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_argDef572  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_argDef572_bits[]	= { ANTLR3_UINT64_LIT(0x0008000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_argDef572	= { FOLLOW_IDENTIFIER_in_argDef572_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeRefDef_in_argDef574  */
static	ANTLR3_BITWORD FOLLOW_typeRefDef_in_argDef574_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typeRefDef_in_argDef574	= { FOLLOW_typeRefDef_in_argDef574_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_51_in_typeRefDef585  */
static	ANTLR3_BITWORD FOLLOW_51_in_typeRefDef585_bits[]	= { ANTLR3_UINT64_LIT(0x3500000004000000), ANTLR3_UINT64_LIT(0x000000000000068C) };
static  ANTLR3_BITSET_LIST FOLLOW_51_in_typeRefDef585	= { FOLLOW_51_in_typeRefDef585_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeRef_in_typeRefDef587  */
static	ANTLR3_BITWORD FOLLOW_typeRef_in_typeRefDef587_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typeRef_in_typeRefDef587	= { FOLLOW_typeRef_in_typeRefDef587_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ifStatement_in_statement609  */
static	ANTLR3_BITWORD FOLLOW_ifStatement_in_statement609_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ifStatement_in_statement609	= { FOLLOW_ifStatement_in_statement609_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_blockStatement_in_statement613  */
static	ANTLR3_BITWORD FOLLOW_blockStatement_in_statement613_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_blockStatement_in_statement613	= { FOLLOW_blockStatement_in_statement613_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_whileStatement_in_statement617  */
static	ANTLR3_BITWORD FOLLOW_whileStatement_in_statement617_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_whileStatement_in_statement617	= { FOLLOW_whileStatement_in_statement617_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_doStatement_in_statement621  */
static	ANTLR3_BITWORD FOLLOW_doStatement_in_statement621_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_doStatement_in_statement621	= { FOLLOW_doStatement_in_statement621_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_breakStatement_in_statement629  */
static	ANTLR3_BITWORD FOLLOW_breakStatement_in_statement629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_breakStatement_in_statement629	= { FOLLOW_breakStatement_in_statement629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expressionStatement_in_statement633  */
static	ANTLR3_BITWORD FOLLOW_expressionStatement_in_statement633_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expressionStatement_in_statement633	= { FOLLOW_expressionStatement_in_statement633_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_65_in_ifStatement644  */
static	ANTLR3_BITWORD FOLLOW_65_in_ifStatement644_bits[]	= { ANTLR3_UINT64_LIT(0x00020A0406044280) };
static  ANTLR3_BITSET_LIST FOLLOW_65_in_ifStatement644	= { FOLLOW_65_in_ifStatement644_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_ifStatement646  */
static	ANTLR3_BITWORD FOLLOW_expr_in_ifStatement646_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_ifStatement646	= { FOLLOW_expr_in_ifStatement646_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_72_in_ifStatement648  */
static	ANTLR3_BITWORD FOLLOW_72_in_ifStatement648_bits[]	= { ANTLR3_UINT64_LIT(0x0A020A0406044280), ANTLR3_UINT64_LIT(0x0000000000002042) };
static  ANTLR3_BITSET_LIST FOLLOW_72_in_ifStatement648	= { FOLLOW_72_in_ifStatement648_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_ifStatement650  */
static	ANTLR3_BITWORD FOLLOW_statement_in_ifStatement650_bits[]	= { ANTLR3_UINT64_LIT(0x8000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_ifStatement650	= { FOLLOW_statement_in_ifStatement650_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_63_in_ifStatement653  */
static	ANTLR3_BITWORD FOLLOW_63_in_ifStatement653_bits[]	= { ANTLR3_UINT64_LIT(0x0A020A0406044280), ANTLR3_UINT64_LIT(0x0000000000002042) };
static  ANTLR3_BITSET_LIST FOLLOW_63_in_ifStatement653	= { FOLLOW_63_in_ifStatement653_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_ifStatement655  */
static	ANTLR3_BITWORD FOLLOW_statement_in_ifStatement655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_ifStatement655	= { FOLLOW_statement_in_ifStatement655_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_57_in_blockStatement666  */
static	ANTLR3_BITWORD FOLLOW_57_in_blockStatement666_bits[]	= { ANTLR3_UINT64_LIT(0x0A020A0406044280), ANTLR3_UINT64_LIT(0x0000000000002043) };
static  ANTLR3_BITSET_LIST FOLLOW_57_in_blockStatement666	= { FOLLOW_57_in_blockStatement666_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_blockStatement668  */
static	ANTLR3_BITWORD FOLLOW_statement_in_blockStatement668_bits[]	= { ANTLR3_UINT64_LIT(0x0A020A0406044280), ANTLR3_UINT64_LIT(0x0000000000002043) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_blockStatement668	= { FOLLOW_statement_in_blockStatement668_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_64_in_blockStatement671  */
static	ANTLR3_BITWORD FOLLOW_64_in_blockStatement671_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_64_in_blockStatement671	= { FOLLOW_64_in_blockStatement671_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_53_in_blockStatement673  */
static	ANTLR3_BITWORD FOLLOW_53_in_blockStatement673_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_53_in_blockStatement673	= { FOLLOW_53_in_blockStatement673_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_77_in_whileStatement682  */
static	ANTLR3_BITWORD FOLLOW_77_in_whileStatement682_bits[]	= { ANTLR3_UINT64_LIT(0x00020A0406044280) };
static  ANTLR3_BITSET_LIST FOLLOW_77_in_whileStatement682	= { FOLLOW_77_in_whileStatement682_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_whileStatement684  */
static	ANTLR3_BITWORD FOLLOW_expr_in_whileStatement684_bits[]	= { ANTLR3_UINT64_LIT(0x4000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_whileStatement684	= { FOLLOW_expr_in_whileStatement684_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_62_in_whileStatement686  */
static	ANTLR3_BITWORD FOLLOW_62_in_whileStatement686_bits[]	= { ANTLR3_UINT64_LIT(0x0A020A0406044280), ANTLR3_UINT64_LIT(0x0000000000002042) };
static  ANTLR3_BITSET_LIST FOLLOW_62_in_whileStatement686	= { FOLLOW_62_in_whileStatement686_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_whileStatement688  */
static	ANTLR3_BITWORD FOLLOW_statement_in_whileStatement688_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_whileStatement688	= { FOLLOW_statement_in_whileStatement688_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_70_in_doStatement697  */
static	ANTLR3_BITWORD FOLLOW_70_in_doStatement697_bits[]	= { ANTLR3_UINT64_LIT(0x0A020A0406044280), ANTLR3_UINT64_LIT(0x0000000000002042) };
static  ANTLR3_BITSET_LIST FOLLOW_70_in_doStatement697	= { FOLLOW_70_in_doStatement697_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_doStatement699  */
static	ANTLR3_BITWORD FOLLOW_statement_in_doStatement699_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000002800) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_doStatement699	= { FOLLOW_statement_in_doStatement699_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_doStatement701  */
static	ANTLR3_BITWORD FOLLOW_set_in_doStatement701_bits[]	= { ANTLR3_UINT64_LIT(0x00020A0406044280) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_doStatement701	= { FOLLOW_set_in_doStatement701_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_doStatement707  */
static	ANTLR3_BITWORD FOLLOW_expr_in_doStatement707_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_doStatement707	= { FOLLOW_expr_in_doStatement707_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_53_in_doStatement709  */
static	ANTLR3_BITWORD FOLLOW_53_in_doStatement709_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_53_in_doStatement709	= { FOLLOW_53_in_doStatement709_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_59_in_breakStatement718  */
static	ANTLR3_BITWORD FOLLOW_59_in_breakStatement718_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_59_in_breakStatement718	= { FOLLOW_59_in_breakStatement718_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_53_in_breakStatement720  */
static	ANTLR3_BITWORD FOLLOW_53_in_breakStatement720_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_53_in_breakStatement720	= { FOLLOW_53_in_breakStatement720_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expressionStatement729  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expressionStatement729_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expressionStatement729	= { FOLLOW_expr_in_expressionStatement729_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_53_in_expressionStatement731  */
static	ANTLR3_BITWORD FOLLOW_53_in_expressionStatement731_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_53_in_expressionStatement731	= { FOLLOW_53_in_expressionStatement731_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignExpr_in_expr743  */
static	ANTLR3_BITWORD FOLLOW_assignExpr_in_expr743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignExpr_in_expr743	= { FOLLOW_assignExpr_in_expr743_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryExpr_in_assignExpr754  */
static	ANTLR3_BITWORD FOLLOW_binaryExpr_in_assignExpr754_bits[]	= { ANTLR3_UINT64_LIT(0x0010800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_binaryExpr_in_assignExpr754	= { FOLLOW_binaryExpr_in_assignExpr754_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_assignExpr756  */
static	ANTLR3_BITWORD FOLLOW_set_in_assignExpr756_bits[]	= { ANTLR3_UINT64_LIT(0x00020A0406044280) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_assignExpr756	= { FOLLOW_set_in_assignExpr756_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryExpr_in_assignExpr764  */
static	ANTLR3_BITWORD FOLLOW_binaryExpr_in_assignExpr764_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_binaryExpr_in_assignExpr764	= { FOLLOW_binaryExpr_in_assignExpr764_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryExpr_in_assignExpr769  */
static	ANTLR3_BITWORD FOLLOW_binaryExpr_in_assignExpr769_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_binaryExpr_in_assignExpr769	= { FOLLOW_binaryExpr_in_assignExpr769_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_additiveExpr_in_binaryExpr779  */
static	ANTLR3_BITWORD FOLLOW_additiveExpr_in_binaryExpr779_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_additiveExpr_in_binaryExpr779	= { FOLLOW_additiveExpr_in_binaryExpr779_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplicativeExpr_in_additiveExpr790  */
static	ANTLR3_BITWORD FOLLOW_multiplicativeExpr_in_additiveExpr790_bits[]	= { ANTLR3_UINT64_LIT(0x0002400000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplicativeExpr_in_additiveExpr790	= { FOLLOW_multiplicativeExpr_in_additiveExpr790_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_additiveExpr792  */
static	ANTLR3_BITWORD FOLLOW_set_in_additiveExpr792_bits[]	= { ANTLR3_UINT64_LIT(0x00020A0406044280) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_additiveExpr792	= { FOLLOW_set_in_additiveExpr792_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplicativeExpr_in_additiveExpr800  */
static	ANTLR3_BITWORD FOLLOW_multiplicativeExpr_in_additiveExpr800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplicativeExpr_in_additiveExpr800	= { FOLLOW_multiplicativeExpr_in_additiveExpr800_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplicativeExpr_in_additiveExpr805  */
static	ANTLR3_BITWORD FOLLOW_multiplicativeExpr_in_additiveExpr805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplicativeExpr_in_additiveExpr805	= { FOLLOW_multiplicativeExpr_in_additiveExpr805_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpr_in_multiplicativeExpr816  */
static	ANTLR3_BITWORD FOLLOW_unaryExpr_in_multiplicativeExpr816_bits[]	= { ANTLR3_UINT64_LIT(0x0004240000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpr_in_multiplicativeExpr816	= { FOLLOW_unaryExpr_in_multiplicativeExpr816_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_multiplicativeExpr818  */
static	ANTLR3_BITWORD FOLLOW_set_in_multiplicativeExpr818_bits[]	= { ANTLR3_UINT64_LIT(0x00020A0406044280) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_multiplicativeExpr818	= { FOLLOW_set_in_multiplicativeExpr818_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpr_in_multiplicativeExpr830  */
static	ANTLR3_BITWORD FOLLOW_unaryExpr_in_multiplicativeExpr830_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpr_in_multiplicativeExpr830	= { FOLLOW_unaryExpr_in_multiplicativeExpr830_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpr_in_multiplicativeExpr834  */
static	ANTLR3_BITWORD FOLLOW_unaryExpr_in_multiplicativeExpr834_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpr_in_multiplicativeExpr834	= { FOLLOW_unaryExpr_in_multiplicativeExpr834_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unOp_in_unaryExpr845  */
static	ANTLR3_BITWORD FOLLOW_unOp_in_unaryExpr845_bits[]	= { ANTLR3_UINT64_LIT(0x00020A0406044280) };
static  ANTLR3_BITSET_LIST FOLLOW_unOp_in_unaryExpr845	= { FOLLOW_unOp_in_unaryExpr845_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpr_in_unaryExpr847  */
static	ANTLR3_BITWORD FOLLOW_unaryExpr_in_unaryExpr847_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpr_in_unaryExpr847	= { FOLLOW_unaryExpr_in_unaryExpr847_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_primaryExpr_in_unaryExpr851  */
static	ANTLR3_BITWORD FOLLOW_primaryExpr_in_unaryExpr851_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_primaryExpr_in_unaryExpr851	= { FOLLOW_primaryExpr_in_unaryExpr851_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_primaryExpr866  */
static	ANTLR3_BITWORD FOLLOW_literal_in_primaryExpr866_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_primaryExpr866	= { FOLLOW_literal_in_primaryExpr866_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_primaryExpr902  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_primaryExpr902_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_primaryExpr902	= { FOLLOW_IDENTIFIER_in_primaryExpr902_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_primaryExpr935  */
static	ANTLR3_BITWORD FOLLOW_43_in_primaryExpr935_bits[]	= { ANTLR3_UINT64_LIT(0x00020A0406044280) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_primaryExpr935	= { FOLLOW_43_in_primaryExpr935_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_primaryExpr937  */
static	ANTLR3_BITWORD FOLLOW_expr_in_primaryExpr937_bits[]	= { ANTLR3_UINT64_LIT(0x0000100000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_primaryExpr937	= { FOLLOW_expr_in_primaryExpr937_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_primaryExpr939  */
static	ANTLR3_BITWORD FOLLOW_44_in_primaryExpr939_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_44_in_primaryExpr939	= { FOLLOW_44_in_primaryExpr939_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_call_in_primaryExpr971  */
static	ANTLR3_BITWORD FOLLOW_call_in_primaryExpr971_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_call_in_primaryExpr971	= { FOLLOW_call_in_primaryExpr971_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_indexer_in_primaryExpr1010  */
static	ANTLR3_BITWORD FOLLOW_indexer_in_primaryExpr1010_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_indexer_in_primaryExpr1010	= { FOLLOW_indexer_in_primaryExpr1010_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_call1051  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_call1051_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_call1051	= { FOLLOW_IDENTIFIER_in_call1051_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_call1053  */
static	ANTLR3_BITWORD FOLLOW_43_in_call1053_bits[]	= { ANTLR3_UINT64_LIT(0x00021A0406044280) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_call1053	= { FOLLOW_43_in_call1053_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_expr_in_call1055  */
static	ANTLR3_BITWORD FOLLOW_list_expr_in_call1055_bits[]	= { ANTLR3_UINT64_LIT(0x0000100000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_list_expr_in_call1055	= { FOLLOW_list_expr_in_call1055_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_call1057  */
static	ANTLR3_BITWORD FOLLOW_44_in_call1057_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_44_in_call1057	= { FOLLOW_44_in_call1057_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_indexer1068  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_indexer1068_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_indexer1068	= { FOLLOW_IDENTIFIER_in_indexer1068_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_indexer1070  */
static	ANTLR3_BITWORD FOLLOW_54_in_indexer1070_bits[]	= { ANTLR3_UINT64_LIT(0x00820A0406044280) };
static  ANTLR3_BITSET_LIST FOLLOW_54_in_indexer1070	= { FOLLOW_54_in_indexer1070_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_expr_in_indexer1072  */
static	ANTLR3_BITWORD FOLLOW_list_expr_in_indexer1072_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_list_expr_in_indexer1072	= { FOLLOW_list_expr_in_indexer1072_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_55_in_indexer1074  */
static	ANTLR3_BITWORD FOLLOW_55_in_indexer1074_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_55_in_indexer1074	= { FOLLOW_55_in_indexer1074_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_list_expr1115  */
static	ANTLR3_BITWORD FOLLOW_expr_in_list_expr1115_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_list_expr1115	= { FOLLOW_expr_in_list_expr1115_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_48_in_list_expr1118  */
static	ANTLR3_BITWORD FOLLOW_48_in_list_expr1118_bits[]	= { ANTLR3_UINT64_LIT(0x00020A0406044280) };
static  ANTLR3_BITSET_LIST FOLLOW_48_in_list_expr1118	= { FOLLOW_48_in_list_expr1118_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_list_expr1120  */
static	ANTLR3_BITWORD FOLLOW_expr_in_list_expr1120_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_list_expr1120	= { FOLLOW_expr_in_list_expr1120_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_63_in_synpred27_MyGrammarTest653  */
static	ANTLR3_BITWORD FOLLOW_63_in_synpred27_MyGrammarTest653_bits[]	= { ANTLR3_UINT64_LIT(0x0A020A0406044280), ANTLR3_UINT64_LIT(0x0000000000002042) };
static  ANTLR3_BITSET_LIST FOLLOW_63_in_synpred27_MyGrammarTest653	= { FOLLOW_63_in_synpred27_MyGrammarTest653_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_synpred27_MyGrammarTest655  */
static	ANTLR3_BITWORD FOLLOW_statement_in_synpred27_MyGrammarTest655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_synpred27_MyGrammarTest655	= { FOLLOW_statement_in_synpred27_MyGrammarTest655_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryExpr_in_synpred31_MyGrammarTest754  */
static	ANTLR3_BITWORD FOLLOW_binaryExpr_in_synpred31_MyGrammarTest754_bits[]	= { ANTLR3_UINT64_LIT(0x0010800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_binaryExpr_in_synpred31_MyGrammarTest754	= { FOLLOW_binaryExpr_in_synpred31_MyGrammarTest754_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_synpred31_MyGrammarTest756  */
static	ANTLR3_BITWORD FOLLOW_set_in_synpred31_MyGrammarTest756_bits[]	= { ANTLR3_UINT64_LIT(0x00020A0406044280) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_synpred31_MyGrammarTest756	= { FOLLOW_set_in_synpred31_MyGrammarTest756_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryExpr_in_synpred31_MyGrammarTest764  */
static	ANTLR3_BITWORD FOLLOW_binaryExpr_in_synpred31_MyGrammarTest764_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_binaryExpr_in_synpred31_MyGrammarTest764	= { FOLLOW_binaryExpr_in_synpred31_MyGrammarTest764_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplicativeExpr_in_synpred33_MyGrammarTest790  */
static	ANTLR3_BITWORD FOLLOW_multiplicativeExpr_in_synpred33_MyGrammarTest790_bits[]	= { ANTLR3_UINT64_LIT(0x0002400000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplicativeExpr_in_synpred33_MyGrammarTest790	= { FOLLOW_multiplicativeExpr_in_synpred33_MyGrammarTest790_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_synpred33_MyGrammarTest792  */
static	ANTLR3_BITWORD FOLLOW_set_in_synpred33_MyGrammarTest792_bits[]	= { ANTLR3_UINT64_LIT(0x00020A0406044280) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_synpred33_MyGrammarTest792	= { FOLLOW_set_in_synpred33_MyGrammarTest792_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplicativeExpr_in_synpred33_MyGrammarTest800  */
static	ANTLR3_BITWORD FOLLOW_multiplicativeExpr_in_synpred33_MyGrammarTest800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplicativeExpr_in_synpred33_MyGrammarTest800	= { FOLLOW_multiplicativeExpr_in_synpred33_MyGrammarTest800_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpr_in_synpred36_MyGrammarTest816  */
static	ANTLR3_BITWORD FOLLOW_unaryExpr_in_synpred36_MyGrammarTest816_bits[]	= { ANTLR3_UINT64_LIT(0x0004240000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpr_in_synpred36_MyGrammarTest816	= { FOLLOW_unaryExpr_in_synpred36_MyGrammarTest816_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_synpred36_MyGrammarTest818  */
static	ANTLR3_BITWORD FOLLOW_set_in_synpred36_MyGrammarTest818_bits[]	= { ANTLR3_UINT64_LIT(0x00020A0406044280) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_synpred36_MyGrammarTest818	= { FOLLOW_set_in_synpred36_MyGrammarTest818_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpr_in_synpred36_MyGrammarTest830  */
static	ANTLR3_BITWORD FOLLOW_unaryExpr_in_synpred36_MyGrammarTest830_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpr_in_synpred36_MyGrammarTest830	= { FOLLOW_unaryExpr_in_synpred36_MyGrammarTest830_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start source
 * MyGrammarTest.g:46:1: source : ( sourceItem )* -> ^( Source ( sourceItem )* ) ;
 */
static MyGrammarTestParser_source_return
source(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_source_return retval;


    pANTLR3_BASE_TREE root_0;

    MyGrammarTestParser_sourceItem_return sourceItem1;
    #undef	RETURN_TYPE_sourceItem1
    #define	RETURN_TYPE_sourceItem1 MyGrammarTestParser_sourceItem_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_sourceItem;
    /* Initialize rule variables
     */

    root_0 = NULL;

    sourceItem1.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;



    stream_sourceItem   = NULL;
    #define CREATE_stream_sourceItem  if (stream_sourceItem == NULL) {stream_sourceItem = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule sourceItem"); }

    retval.tree  = NULL;

    {
        // MyGrammarTest.g:46:8: ( ( sourceItem )* -> ^( Source ( sourceItem )* ) )
        // MyGrammarTest.g:46:10: ( sourceItem )*
        {
            // MyGrammarTest.g:46:10: ( sourceItem )*

            for (;;)
            {
                int alt1=2;
                switch ( LA(1) )
                {
                case 68:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // MyGrammarTest.g:46:10: sourceItem
            	    {
            	        FOLLOWPUSH(FOLLOW_sourceItem_in_source184);
            	        sourceItem1=sourceItem(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesourceEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) { CREATE_stream_sourceItem; stream_sourceItem->add(stream_sourceItem, sourceItem1.tree, NULL); }

            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


            /* AST REWRITE
             * elements          : sourceItem
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 

            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 46:22: -> ^( Source ( sourceItem )* )
            	{
            	    // MyGrammarTest.g:46:25: ^( Source ( sourceItem )* )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, Source, (pANTLR3_UINT8)"Source")
            	        , root_1));

            	        // MyGrammarTest.g:46:34: ( sourceItem )*
            	        {
            	        	while ( (stream_sourceItem != NULL && stream_sourceItem->hasNext(stream_sourceItem))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_sourceItem == NULL ? NULL : stream_sourceItem->nextTree(stream_sourceItem));

            	        	}
            	        	if (stream_sourceItem != NULL) stream_sourceItem->reset(stream_sourceItem);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto rulesourceEx; /* Prevent compiler warnings */
    rulesourceEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_sourceItem != NULL) stream_sourceItem->free(stream_sourceItem);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end source */

/**
 * $ANTLR start sourceItem
 * MyGrammarTest.g:48:1: sourceItem : funcDef -> ^( SourceItem funcDef ) ;
 */
static MyGrammarTestParser_sourceItem_return
sourceItem(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_sourceItem_return retval;


    pANTLR3_BASE_TREE root_0;

    MyGrammarTestParser_funcDef_return funcDef2;
    #undef	RETURN_TYPE_funcDef2
    #define	RETURN_TYPE_funcDef2 MyGrammarTestParser_funcDef_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_funcDef;
    /* Initialize rule variables
     */

    root_0 = NULL;

    funcDef2.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;



    stream_funcDef   = NULL;
    #define CREATE_stream_funcDef  if (stream_funcDef == NULL) {stream_funcDef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule funcDef"); }

    retval.tree  = NULL;

    {
        // MyGrammarTest.g:48:12: ( funcDef -> ^( SourceItem funcDef ) )
        // MyGrammarTest.g:48:14: funcDef
        {
            FOLLOWPUSH(FOLLOW_funcDef_in_sourceItem202);
            funcDef2=funcDef(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesourceItemEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) { CREATE_stream_funcDef; stream_funcDef->add(stream_funcDef, funcDef2.tree, NULL); }

            /* AST REWRITE
             * elements          : funcDef
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 

            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 48:22: -> ^( SourceItem funcDef )
            	{
            	    // MyGrammarTest.g:48:25: ^( SourceItem funcDef )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, SourceItem, (pANTLR3_UINT8)"SourceItem")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_funcDef == NULL ? NULL : stream_funcDef->nextTree(stream_funcDef));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto rulesourceItemEx; /* Prevent compiler warnings */
    rulesourceItemEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_funcDef != NULL) stream_funcDef->free(stream_funcDef);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end sourceItem */

/**
 * $ANTLR start funcDef
 * MyGrammarTest.g:49:10: fragment funcDef : 'method' funcSignature ( body | ';' ) -> ^( FuncDef funcSignature ( body )? ) ;
 */
static MyGrammarTestParser_funcDef_return
funcDef(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_funcDef_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal3;
    pANTLR3_COMMON_TOKEN    char_literal6;
    MyGrammarTestParser_funcSignature_return funcSignature4;
    #undef	RETURN_TYPE_funcSignature4
    #define	RETURN_TYPE_funcSignature4 MyGrammarTestParser_funcSignature_return

    MyGrammarTestParser_body_return body5;
    #undef	RETURN_TYPE_body5
    #define	RETURN_TYPE_body5 MyGrammarTestParser_body_return

    pANTLR3_BASE_TREE string_literal3_tree;
    pANTLR3_BASE_TREE char_literal6_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_68;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_53;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_funcSignature;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_body;
    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal3       = NULL;
    char_literal6       = NULL;
    funcSignature4.tree = NULL;

    body5.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal3_tree   = NULL;
    char_literal6_tree   = NULL;

    stream_68   = NULL;
    #define CREATE_stream_68  if (stream_68 == NULL) {stream_68 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 68"); } 
    stream_53   = NULL;
    #define CREATE_stream_53  if (stream_53 == NULL) {stream_53 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 53"); } 
    stream_funcSignature   = NULL;
    #define CREATE_stream_funcSignature  if (stream_funcSignature == NULL) {stream_funcSignature = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule funcSignature"); }
    stream_body   = NULL;
    #define CREATE_stream_body  if (stream_body == NULL) {stream_body = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule body"); }

    retval.tree  = NULL;

    {
        // MyGrammarTest.g:49:18: ( 'method' funcSignature ( body | ';' ) -> ^( FuncDef funcSignature ( body )? ) )
        // MyGrammarTest.g:49:20: 'method' funcSignature ( body | ';' )
        {
            string_literal3 = (pANTLR3_COMMON_TOKEN) MATCHT(68, &FOLLOW_68_in_funcDef219);
            if  (HASEXCEPTION())
            {
                goto rulefuncDefEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             
            if ( BACKTRACKING==0 ) { CREATE_stream_68; stream_68->add(stream_68, string_literal3, NULL); }


            FOLLOWPUSH(FOLLOW_funcSignature_in_funcDef221);
            funcSignature4=funcSignature(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefuncDefEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) { CREATE_stream_funcSignature; stream_funcSignature->add(stream_funcSignature, funcSignature4.tree, NULL); }

            // MyGrammarTest.g:49:43: ( body | ';' )
            {
                int alt2=2;
                switch ( LA(1) )
                {
                case 57:
                case 76:
                	{
                		alt2=1;
                	}
                    break;
                case 53:
                	{
                		alt2=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return retval;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 2;
                    EXCEPTION->state        = 0;


                    goto rulefuncDefEx;

                }

                switch (alt2)
                {
            	case 1:
            	    // MyGrammarTest.g:49:45: body
            	    {
            	        FOLLOWPUSH(FOLLOW_body_in_funcDef225);
            	        body5=body(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefuncDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) { CREATE_stream_body; stream_body->add(stream_body, body5.tree, NULL); }

            	    }
            	    break;
            	case 2:
            	    // MyGrammarTest.g:49:52: ';'
            	    {
            	        char_literal6 = (pANTLR3_COMMON_TOKEN) MATCHT(53, &FOLLOW_53_in_funcDef229);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefuncDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( BACKTRACKING==0 ) { CREATE_stream_53; stream_53->add(stream_53, char_literal6, NULL); }


            	    }
            	    break;

                }
            }

            /* AST REWRITE
             * elements          : funcSignature, body
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 

            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 49:58: -> ^( FuncDef funcSignature ( body )? )
            	{
            	    // MyGrammarTest.g:49:61: ^( FuncDef funcSignature ( body )? )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FuncDef, (pANTLR3_UINT8)"FuncDef")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_funcSignature == NULL ? NULL : stream_funcSignature->nextTree(stream_funcSignature));

            	        // MyGrammarTest.g:49:85: ( body )?
            	        {
            	        	if ( (stream_body != NULL && stream_body->hasNext(stream_body))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_body == NULL ? NULL : stream_body->nextTree(stream_body));

            	        	}
            	        	if ( stream_body != NULL) stream_body->reset(stream_body);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto rulefuncDefEx; /* Prevent compiler warnings */
    rulefuncDefEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_68 != NULL) stream_68->free(stream_68);
        if (stream_53 != NULL) stream_53->free(stream_53);
        if (stream_funcSignature != NULL) stream_funcSignature->free(stream_funcSignature);
        if (stream_body != NULL) stream_body->free(stream_body);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end funcDef */

/**
 * $ANTLR start body
 * MyGrammarTest.g:50:10: fragment body : ( 'var' ( list_identifier ( ':' typeRef )? ';' )* )? blockStatement -> ^( BodySig 'var' ( ^( Vars list_identifier ( typeRef )? ) )* blockStatement ) ;
 */
static MyGrammarTestParser_body_return
body(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_body_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal7;
    pANTLR3_COMMON_TOKEN    char_literal9;
    pANTLR3_COMMON_TOKEN    char_literal11;
    MyGrammarTestParser_list_identifier_return list_identifier8;
    #undef	RETURN_TYPE_list_identifier8
    #define	RETURN_TYPE_list_identifier8 MyGrammarTestParser_list_identifier_return

    MyGrammarTestParser_typeRef_return typeRef10;
    #undef	RETURN_TYPE_typeRef10
    #define	RETURN_TYPE_typeRef10 MyGrammarTestParser_typeRef_return

    MyGrammarTestParser_blockStatement_return blockStatement12;
    #undef	RETURN_TYPE_blockStatement12
    #define	RETURN_TYPE_blockStatement12 MyGrammarTestParser_blockStatement_return

    pANTLR3_BASE_TREE string_literal7_tree;
    pANTLR3_BASE_TREE char_literal9_tree;
    pANTLR3_BASE_TREE char_literal11_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_51;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_53;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_76;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_list_identifier;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_blockStatement;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_typeRef;
    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal7       = NULL;
    char_literal9       = NULL;
    char_literal11       = NULL;
    list_identifier8.tree = NULL;

    typeRef10.tree = NULL;

    blockStatement12.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal7_tree   = NULL;
    char_literal9_tree   = NULL;
    char_literal11_tree   = NULL;

    stream_51   = NULL;
    #define CREATE_stream_51  if (stream_51 == NULL) {stream_51 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 51"); } 
    stream_53   = NULL;
    #define CREATE_stream_53  if (stream_53 == NULL) {stream_53 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 53"); } 
    stream_76   = NULL;
    #define CREATE_stream_76  if (stream_76 == NULL) {stream_76 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 76"); } 
    stream_list_identifier   = NULL;
    #define CREATE_stream_list_identifier  if (stream_list_identifier == NULL) {stream_list_identifier = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule list_identifier"); }
    stream_blockStatement   = NULL;
    #define CREATE_stream_blockStatement  if (stream_blockStatement == NULL) {stream_blockStatement = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule blockStatement"); }
    stream_typeRef   = NULL;
    #define CREATE_stream_typeRef  if (stream_typeRef == NULL) {stream_typeRef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule typeRef"); }

    retval.tree  = NULL;

    {
        // MyGrammarTest.g:50:15: ( ( 'var' ( list_identifier ( ':' typeRef )? ';' )* )? blockStatement -> ^( BodySig 'var' ( ^( Vars list_identifier ( typeRef )? ) )* blockStatement ) )
        // MyGrammarTest.g:50:17: ( 'var' ( list_identifier ( ':' typeRef )? ';' )* )? blockStatement
        {
            // MyGrammarTest.g:50:17: ( 'var' ( list_identifier ( ':' typeRef )? ';' )* )?
            {
                int alt5=2;
                switch ( LA(1) )
                {
                    case 76:
                    	{
                    		alt5=1;
                    	}
                        break;
                }

                switch (alt5)
                {
            	case 1:
            	    // MyGrammarTest.g:50:19: 'var' ( list_identifier ( ':' typeRef )? ';' )*
            	    {
            	        string_literal7 = (pANTLR3_COMMON_TOKEN) MATCHT(76, &FOLLOW_76_in_body253);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebodyEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( BACKTRACKING==0 ) { CREATE_stream_76; stream_76->add(stream_76, string_literal7, NULL); }


            	        // MyGrammarTest.g:50:25: ( list_identifier ( ':' typeRef )? ';' )*

            	        for (;;)
            	        {
            	            int alt4=2;
            	            switch ( LA(1) )
            	            {
            	            case IDENTIFIER:
            	            case 51:
            	            case 53:
            	            	{
            	            		alt4=1;
            	            	}
            	                break;

            	            }

            	            switch (alt4)
            	            {
            	        	case 1:
            	        	    // MyGrammarTest.g:50:27: list_identifier ( ':' typeRef )? ';'
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_list_identifier_in_body257);
            	        	        list_identifier8=list_identifier(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebodyEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_list_identifier; stream_list_identifier->add(stream_list_identifier, list_identifier8.tree, NULL); }

            	        	        // MyGrammarTest.g:50:43: ( ':' typeRef )?
            	        	        {
            	        	            int alt3=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case 51:
            	        	                	{
            	        	                		alt3=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt3)
            	        	            {
            	        	        	case 1:
            	        	        	    // MyGrammarTest.g:50:44: ':' typeRef
            	        	        	    {
            	        	        	        char_literal9 = (pANTLR3_COMMON_TOKEN) MATCHT(51, &FOLLOW_51_in_body260);
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulebodyEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }
            	        	        	         
            	        	        	        if ( BACKTRACKING==0 ) { CREATE_stream_51; stream_51->add(stream_51, char_literal9, NULL); }


            	        	        	        FOLLOWPUSH(FOLLOW_typeRef_in_body262);
            	        	        	        typeRef10=typeRef(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulebodyEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }

            	        	        	        if ( BACKTRACKING==0 ) { CREATE_stream_typeRef; stream_typeRef->add(stream_typeRef, typeRef10.tree, NULL); }

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        char_literal11 = (pANTLR3_COMMON_TOKEN) MATCHT(53, &FOLLOW_53_in_body266);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebodyEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_53; stream_53->add(stream_53, char_literal11, NULL); }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop4;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop4: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_blockStatement_in_body274);
            blockStatement12=blockStatement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebodyEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) { CREATE_stream_blockStatement; stream_blockStatement->add(stream_blockStatement, blockStatement12.tree, NULL); }

            /* AST REWRITE
             * elements          : typeRef, 76, blockStatement, list_identifier
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 

            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 50:83: -> ^( BodySig 'var' ( ^( Vars list_identifier ( typeRef )? ) )* blockStatement )
            	{
            	    // MyGrammarTest.g:50:86: ^( BodySig 'var' ( ^( Vars list_identifier ( typeRef )? ) )* blockStatement )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, BodySig, (pANTLR3_UINT8)"BodySig")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, 
            	        stream_76 == NULL ? NULL : stream_76->nextNode(stream_76)
            	        );

            	        // MyGrammarTest.g:50:102: ( ^( Vars list_identifier ( typeRef )? ) )*
            	        {
            	        	while ( (stream_list_identifier != NULL && stream_list_identifier->hasNext(stream_list_identifier))  )
            	        	{
            	        		// MyGrammarTest.g:50:102: ^( Vars list_identifier ( typeRef )? )
            	        		{
            	        		    pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        		    root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        		    (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, Vars, (pANTLR3_UINT8)"Vars")
            	        		    , root_2));

            	        		    ADAPTOR->addChild(ADAPTOR, root_2, stream_list_identifier == NULL ? NULL : stream_list_identifier->nextTree(stream_list_identifier));

            	        		    // MyGrammarTest.g:50:125: ( typeRef )?
            	        		    {
            	        		    	if ( (stream_typeRef != NULL && stream_typeRef->hasNext(stream_typeRef))  )
            	        		    	{
            	        		    		ADAPTOR->addChild(ADAPTOR, root_2, stream_typeRef == NULL ? NULL : stream_typeRef->nextTree(stream_typeRef));

            	        		    	}
            	        		    	if ( stream_typeRef != NULL) stream_typeRef->reset(stream_typeRef);

            	        		    }

            	        		    ADAPTOR->addChild(ADAPTOR, root_1, root_2);
            	        		}

            	        	}
            	        	if (stream_list_identifier != NULL) stream_list_identifier->reset(stream_list_identifier);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_blockStatement == NULL ? NULL : stream_blockStatement->nextTree(stream_blockStatement));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto rulebodyEx; /* Prevent compiler warnings */
    rulebodyEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_51 != NULL) stream_51->free(stream_51);
        if (stream_53 != NULL) stream_53->free(stream_53);
        if (stream_76 != NULL) stream_76->free(stream_76);
        if (stream_list_identifier != NULL) stream_list_identifier->free(stream_list_identifier);
        if (stream_blockStatement != NULL) stream_blockStatement->free(stream_blockStatement);
        if (stream_typeRef != NULL) stream_typeRef->free(stream_typeRef);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end body */

/**
 * $ANTLR start list_identifier
 * MyGrammarTest.g:51:1: list_identifier : ( IDENTIFIER ( ',' IDENTIFIER )* )? -> ^( ListIdentifier ( IDENTIFIER )* ) ;
 */
static MyGrammarTestParser_list_identifier_return
list_identifier(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_list_identifier_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER13;
    pANTLR3_COMMON_TOKEN    char_literal14;
    pANTLR3_COMMON_TOKEN    IDENTIFIER15;

    pANTLR3_BASE_TREE IDENTIFIER13_tree;
    pANTLR3_BASE_TREE char_literal14_tree;
    pANTLR3_BASE_TREE IDENTIFIER15_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_48;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER;

    /* Initialize rule variables
     */

    root_0 = NULL;

    IDENTIFIER13       = NULL;
    char_literal14       = NULL;
    IDENTIFIER15       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IDENTIFIER13_tree   = NULL;
    char_literal14_tree   = NULL;
    IDENTIFIER15_tree   = NULL;

    stream_48   = NULL;
    #define CREATE_stream_48  if (stream_48 == NULL) {stream_48 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 48"); } 
    stream_IDENTIFIER   = NULL;
    #define CREATE_stream_IDENTIFIER  if (stream_IDENTIFIER == NULL) {stream_IDENTIFIER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER"); } 

    retval.tree  = NULL;

    {
        // MyGrammarTest.g:51:16: ( ( IDENTIFIER ( ',' IDENTIFIER )* )? -> ^( ListIdentifier ( IDENTIFIER )* ) )
        // MyGrammarTest.g:51:18: ( IDENTIFIER ( ',' IDENTIFIER )* )?
        {
            // MyGrammarTest.g:51:18: ( IDENTIFIER ( ',' IDENTIFIER )* )?
            {
                int alt7=2;
                switch ( LA(1) )
                {
                    case IDENTIFIER:
                    	{
                    		alt7=1;
                    	}
                        break;
                }

                switch (alt7)
                {
            	case 1:
            	    // MyGrammarTest.g:51:19: IDENTIFIER ( ',' IDENTIFIER )*
            	    {
            	        IDENTIFIER13 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_list_identifier303);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelist_identifierEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( BACKTRACKING==0 ) { CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, IDENTIFIER13, NULL); }


            	        // MyGrammarTest.g:51:30: ( ',' IDENTIFIER )*

            	        for (;;)
            	        {
            	            int alt6=2;
            	            switch ( LA(1) )
            	            {
            	            case 48:
            	            	{
            	            		alt6=1;
            	            	}
            	                break;

            	            }

            	            switch (alt6)
            	            {
            	        	case 1:
            	        	    // MyGrammarTest.g:51:31: ',' IDENTIFIER
            	        	    {
            	        	        char_literal14 = (pANTLR3_COMMON_TOKEN) MATCHT(48, &FOLLOW_48_in_list_identifier306);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelist_identifierEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_48; stream_48->add(stream_48, char_literal14, NULL); }


            	        	        IDENTIFIER15 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_list_identifier308);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelist_identifierEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, IDENTIFIER15, NULL); }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop6;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop6: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            /* AST REWRITE
             * elements          : IDENTIFIER
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 

            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 51:50: -> ^( ListIdentifier ( IDENTIFIER )* )
            	{
            	    // MyGrammarTest.g:51:53: ^( ListIdentifier ( IDENTIFIER )* )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ListIdentifier, (pANTLR3_UINT8)"ListIdentifier")
            	        , root_1));

            	        // MyGrammarTest.g:51:70: ( IDENTIFIER )*
            	        {
            	        	while ( (stream_IDENTIFIER != NULL && stream_IDENTIFIER->hasNext(stream_IDENTIFIER))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, 
            	        		stream_IDENTIFIER == NULL ? NULL : stream_IDENTIFIER->nextNode(stream_IDENTIFIER)
            	        		);

            	        	}
            	        	if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->reset(stream_IDENTIFIER);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto rulelist_identifierEx; /* Prevent compiler warnings */
    rulelist_identifierEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_48 != NULL) stream_48->free(stream_48);
        if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->free(stream_IDENTIFIER);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end list_identifier */

/**
 * $ANTLR start typeRef
 * MyGrammarTest.g:53:1: typeRef : ( builtin -> ^( BuiltinType builtin ) | custom -> ^( CustomType custom ) | array );
 */
static MyGrammarTestParser_typeRef_return
typeRef(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_typeRef_return retval;


    pANTLR3_BASE_TREE root_0;

    MyGrammarTestParser_builtin_return builtin16;
    #undef	RETURN_TYPE_builtin16
    #define	RETURN_TYPE_builtin16 MyGrammarTestParser_builtin_return

    MyGrammarTestParser_custom_return custom17;
    #undef	RETURN_TYPE_custom17
    #define	RETURN_TYPE_custom17 MyGrammarTestParser_custom_return

    MyGrammarTestParser_array_return array18;
    #undef	RETURN_TYPE_array18
    #define	RETURN_TYPE_array18 MyGrammarTestParser_array_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_builtin;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_custom;
    /* Initialize rule variables
     */

    root_0 = NULL;

    builtin16.tree = NULL;

    custom17.tree = NULL;

    array18.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;



    stream_builtin   = NULL;
    #define CREATE_stream_builtin  if (stream_builtin == NULL) {stream_builtin = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule builtin"); }
    stream_custom   = NULL;
    #define CREATE_stream_custom  if (stream_custom == NULL) {stream_custom = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule custom"); }

    retval.tree  = NULL;

    {
        {
            //  MyGrammarTest.g:53:9: ( builtin -> ^( BuiltinType builtin ) | custom -> ^( CustomType custom ) | array )

            ANTLR3_UINT32 alt8;

            alt8=3;

            switch ( LA(1) )
            {
            case 58:
            case 60:
            case 61:
            case 66:
            case 67:
            case 71:
            case 73:
            case 74:
            	{
            		alt8=1;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt8=2;
            	}
                break;
            case 56:
            	{
            		alt8=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 8;
                EXCEPTION->state        = 0;


                goto ruletypeRefEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // MyGrammarTest.g:53:11: builtin
        	    {
        	        FOLLOWPUSH(FOLLOW_builtin_in_typeRef330);
        	        builtin16=builtin(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletypeRefEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) { CREATE_stream_builtin; stream_builtin->add(stream_builtin, builtin16.tree, NULL); }

        	        /* AST REWRITE
        	         * elements          : builtin
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        if ( BACKTRACKING==0 ) 

        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 53:19: -> ^( BuiltinType builtin )
        	        	{
        	        	    // MyGrammarTest.g:53:22: ^( BuiltinType builtin )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, BuiltinType, (pANTLR3_UINT8)"BuiltinType")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_builtin == NULL ? NULL : stream_builtin->nextTree(stream_builtin));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // MyGrammarTest.g:54:7: custom
        	    {
        	        FOLLOWPUSH(FOLLOW_custom_in_typeRef346);
        	        custom17=custom(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletypeRefEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) { CREATE_stream_custom; stream_custom->add(stream_custom, custom17.tree, NULL); }

        	        /* AST REWRITE
        	         * elements          : custom
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        if ( BACKTRACKING==0 ) 

        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 54:14: -> ^( CustomType custom )
        	        	{
        	        	    // MyGrammarTest.g:54:17: ^( CustomType custom )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, CustomType, (pANTLR3_UINT8)"CustomType")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_custom == NULL ? NULL : stream_custom->nextTree(stream_custom));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 3:
        	    // MyGrammarTest.g:55:7: array
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_array_in_typeRef362);
        	        array18=array(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletypeRefEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, array18.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletypeRefEx; /* Prevent compiler warnings */
    ruletypeRefEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_builtin != NULL) stream_builtin->free(stream_builtin);
        if (stream_custom != NULL) stream_custom->free(stream_custom);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end typeRef */

/**
 * $ANTLR start builtin
 * MyGrammarTest.g:56:10: fragment builtin : ( 'bool' | 'byte' | 'int' | 'uint' | 'long' | 'ulong' | 'char' | 'string' ) ;
 */
static MyGrammarTestParser_builtin_return
builtin(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_builtin_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set19;

    pANTLR3_BASE_TREE set19_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set19       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set19_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:56:18: ( ( 'bool' | 'byte' | 'int' | 'uint' | 'long' | 'ulong' | 'char' | 'string' ) )
        // MyGrammarTest.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set19=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == 58 || ((LA(1) >= 60) && (LA(1) <= 61)) || ((LA(1) >= 66) && (LA(1) <= 67)) || LA(1) == 71 || ((LA(1) >= 73) && (LA(1) <= 74)) )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set19))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulebuiltinEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebuiltinEx; /* Prevent compiler warnings */
    rulebuiltinEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end builtin */

/**
 * $ANTLR start custom
 * MyGrammarTest.g:57:10: fragment custom : IDENTIFIER ;
 */
static MyGrammarTestParser_custom_return
custom(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_custom_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER20;

    pANTLR3_BASE_TREE IDENTIFIER20_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    IDENTIFIER20       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IDENTIFIER20_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:57:17: ( IDENTIFIER )
        // MyGrammarTest.g:57:19: IDENTIFIER
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            IDENTIFIER20 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_custom458);
            if  (HASEXCEPTION())
            {
                goto rulecustomEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            IDENTIFIER20_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER20));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER20_tree);
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulecustomEx; /* Prevent compiler warnings */
    rulecustomEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end custom */

/**
 * $ANTLR start array
 * MyGrammarTest.g:58:10: fragment array : 'array' '[' ( ',' )* ']' 'of' typeRef -> ^( ArrayType 'array' typeRef ) ;
 */
static MyGrammarTestParser_array_return
array(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_array_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal21;
    pANTLR3_COMMON_TOKEN    char_literal22;
    pANTLR3_COMMON_TOKEN    char_literal23;
    pANTLR3_COMMON_TOKEN    char_literal24;
    pANTLR3_COMMON_TOKEN    string_literal25;
    MyGrammarTestParser_typeRef_return typeRef26;
    #undef	RETURN_TYPE_typeRef26
    #define	RETURN_TYPE_typeRef26 MyGrammarTestParser_typeRef_return

    pANTLR3_BASE_TREE string_literal21_tree;
    pANTLR3_BASE_TREE char_literal22_tree;
    pANTLR3_BASE_TREE char_literal23_tree;
    pANTLR3_BASE_TREE char_literal24_tree;
    pANTLR3_BASE_TREE string_literal25_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_55;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_69;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_48;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_typeRef;
    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal21       = NULL;
    char_literal22       = NULL;
    char_literal23       = NULL;
    char_literal24       = NULL;
    string_literal25       = NULL;
    typeRef26.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal21_tree   = NULL;
    char_literal22_tree   = NULL;
    char_literal23_tree   = NULL;
    char_literal24_tree   = NULL;
    string_literal25_tree   = NULL;

    stream_55   = NULL;
    #define CREATE_stream_55  if (stream_55 == NULL) {stream_55 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 55"); } 
    stream_56   = NULL;
    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 56"); } 
    stream_69   = NULL;
    #define CREATE_stream_69  if (stream_69 == NULL) {stream_69 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 69"); } 
    stream_48   = NULL;
    #define CREATE_stream_48  if (stream_48 == NULL) {stream_48 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 48"); } 
    stream_54   = NULL;
    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 54"); } 
    stream_typeRef   = NULL;
    #define CREATE_stream_typeRef  if (stream_typeRef == NULL) {stream_typeRef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule typeRef"); }

    retval.tree  = NULL;

    {
        // MyGrammarTest.g:58:16: ( 'array' '[' ( ',' )* ']' 'of' typeRef -> ^( ArrayType 'array' typeRef ) )
        // MyGrammarTest.g:58:18: 'array' '[' ( ',' )* ']' 'of' typeRef
        {
            string_literal21 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_array468);
            if  (HASEXCEPTION())
            {
                goto rulearrayEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             
            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, string_literal21, NULL); }


            char_literal22 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_array470);
            if  (HASEXCEPTION())
            {
                goto rulearrayEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             
            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal22, NULL); }


            // MyGrammarTest.g:58:30: ( ',' )*

            for (;;)
            {
                int alt9=2;
                switch ( LA(1) )
                {
                case 48:
                	{
                		alt9=1;
                	}
                    break;

                }

                switch (alt9)
                {
            	case 1:
            	    // MyGrammarTest.g:58:31: ','
            	    {
            	        char_literal23 = (pANTLR3_COMMON_TOKEN) MATCHT(48, &FOLLOW_48_in_array473);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulearrayEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( BACKTRACKING==0 ) { CREATE_stream_48; stream_48->add(stream_48, char_literal23, NULL); }


            	    }
            	    break;

            	default:
            	    goto loop9;	/* break out of the loop */
            	    break;
                }
            }
            loop9: ; /* Jump out to here if this rule does not match */


            char_literal24 = (pANTLR3_COMMON_TOKEN) MATCHT(55, &FOLLOW_55_in_array477);
            if  (HASEXCEPTION())
            {
                goto rulearrayEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             
            if ( BACKTRACKING==0 ) { CREATE_stream_55; stream_55->add(stream_55, char_literal24, NULL); }


            string_literal25 = (pANTLR3_COMMON_TOKEN) MATCHT(69, &FOLLOW_69_in_array479);
            if  (HASEXCEPTION())
            {
                goto rulearrayEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             
            if ( BACKTRACKING==0 ) { CREATE_stream_69; stream_69->add(stream_69, string_literal25, NULL); }


            FOLLOWPUSH(FOLLOW_typeRef_in_array481);
            typeRef26=typeRef(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulearrayEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) { CREATE_stream_typeRef; stream_typeRef->add(stream_typeRef, typeRef26.tree, NULL); }

            /* AST REWRITE
             * elements          : typeRef, 56
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 

            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 58:54: -> ^( ArrayType 'array' typeRef )
            	{
            	    // MyGrammarTest.g:58:57: ^( ArrayType 'array' typeRef )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ArrayType, (pANTLR3_UINT8)"ArrayType")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, 
            	        stream_56 == NULL ? NULL : stream_56->nextNode(stream_56)
            	        );

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_typeRef == NULL ? NULL : stream_typeRef->nextTree(stream_typeRef));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto rulearrayEx; /* Prevent compiler warnings */
    rulearrayEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_55 != NULL) stream_55->free(stream_55);
        if (stream_56 != NULL) stream_56->free(stream_56);
        if (stream_69 != NULL) stream_69->free(stream_69);
        if (stream_48 != NULL) stream_48->free(stream_48);
        if (stream_54 != NULL) stream_54->free(stream_54);
        if (stream_typeRef != NULL) stream_typeRef->free(stream_typeRef);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end array */

/**
 * $ANTLR start funcSignature
 * MyGrammarTest.g:60:1: funcSignature : IDENTIFIER '(' list_argDef ')' ( typeRefDef )? -> ^( FuncSignature IDENTIFIER list_argDef ( typeRefDef )? ) ;
 */
static MyGrammarTestParser_funcSignature_return
funcSignature(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_funcSignature_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER27;
    pANTLR3_COMMON_TOKEN    char_literal28;
    pANTLR3_COMMON_TOKEN    char_literal30;
    MyGrammarTestParser_list_argDef_return list_argDef29;
    #undef	RETURN_TYPE_list_argDef29
    #define	RETURN_TYPE_list_argDef29 MyGrammarTestParser_list_argDef_return

    MyGrammarTestParser_typeRefDef_return typeRefDef31;
    #undef	RETURN_TYPE_typeRefDef31
    #define	RETURN_TYPE_typeRefDef31 MyGrammarTestParser_typeRefDef_return

    pANTLR3_BASE_TREE IDENTIFIER27_tree;
    pANTLR3_BASE_TREE char_literal28_tree;
    pANTLR3_BASE_TREE char_literal30_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_44;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_43;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_typeRefDef;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_list_argDef;
    /* Initialize rule variables
     */

    root_0 = NULL;

    IDENTIFIER27       = NULL;
    char_literal28       = NULL;
    char_literal30       = NULL;
    list_argDef29.tree = NULL;

    typeRefDef31.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IDENTIFIER27_tree   = NULL;
    char_literal28_tree   = NULL;
    char_literal30_tree   = NULL;

    stream_44   = NULL;
    #define CREATE_stream_44  if (stream_44 == NULL) {stream_44 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 44"); } 
    stream_IDENTIFIER   = NULL;
    #define CREATE_stream_IDENTIFIER  if (stream_IDENTIFIER == NULL) {stream_IDENTIFIER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER"); } 
    stream_43   = NULL;
    #define CREATE_stream_43  if (stream_43 == NULL) {stream_43 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 43"); } 
    stream_typeRefDef   = NULL;
    #define CREATE_stream_typeRefDef  if (stream_typeRefDef == NULL) {stream_typeRefDef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule typeRefDef"); }
    stream_list_argDef   = NULL;
    #define CREATE_stream_list_argDef  if (stream_list_argDef == NULL) {stream_list_argDef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule list_argDef"); }

    retval.tree  = NULL;

    {
        // MyGrammarTest.g:60:15: ( IDENTIFIER '(' list_argDef ')' ( typeRefDef )? -> ^( FuncSignature IDENTIFIER list_argDef ( typeRefDef )? ) )
        // MyGrammarTest.g:60:17: IDENTIFIER '(' list_argDef ')' ( typeRefDef )?
        {
            IDENTIFIER27 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_funcSignature500);
            if  (HASEXCEPTION())
            {
                goto rulefuncSignatureEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             
            if ( BACKTRACKING==0 ) { CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, IDENTIFIER27, NULL); }


            char_literal28 = (pANTLR3_COMMON_TOKEN) MATCHT(43, &FOLLOW_43_in_funcSignature502);
            if  (HASEXCEPTION())
            {
                goto rulefuncSignatureEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             
            if ( BACKTRACKING==0 ) { CREATE_stream_43; stream_43->add(stream_43, char_literal28, NULL); }


            FOLLOWPUSH(FOLLOW_list_argDef_in_funcSignature504);
            list_argDef29=list_argDef(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefuncSignatureEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) { CREATE_stream_list_argDef; stream_list_argDef->add(stream_list_argDef, list_argDef29.tree, NULL); }

            char_literal30 = (pANTLR3_COMMON_TOKEN) MATCHT(44, &FOLLOW_44_in_funcSignature506);
            if  (HASEXCEPTION())
            {
                goto rulefuncSignatureEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             
            if ( BACKTRACKING==0 ) { CREATE_stream_44; stream_44->add(stream_44, char_literal30, NULL); }


            // MyGrammarTest.g:60:48: ( typeRefDef )?
            {
                int alt10=2;
                switch ( LA(1) )
                {
                    case 51:
                    	{
                    		alt10=1;
                    	}
                        break;
                }

                switch (alt10)
                {
            	case 1:
            	    // MyGrammarTest.g:60:48: typeRefDef
            	    {
            	        FOLLOWPUSH(FOLLOW_typeRefDef_in_funcSignature508);
            	        typeRefDef31=typeRefDef(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefuncSignatureEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) { CREATE_stream_typeRefDef; stream_typeRefDef->add(stream_typeRefDef, typeRefDef31.tree, NULL); }

            	    }
            	    break;

                }
            }

            /* AST REWRITE
             * elements          : list_argDef, typeRefDef, IDENTIFIER
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 

            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 60:60: -> ^( FuncSignature IDENTIFIER list_argDef ( typeRefDef )? )
            	{
            	    // MyGrammarTest.g:60:63: ^( FuncSignature IDENTIFIER list_argDef ( typeRefDef )? )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FuncSignature, (pANTLR3_UINT8)"FuncSignature")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, 
            	        stream_IDENTIFIER == NULL ? NULL : stream_IDENTIFIER->nextNode(stream_IDENTIFIER)
            	        );

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_list_argDef == NULL ? NULL : stream_list_argDef->nextTree(stream_list_argDef));

            	        // MyGrammarTest.g:60:102: ( typeRefDef )?
            	        {
            	        	if ( (stream_typeRefDef != NULL && stream_typeRefDef->hasNext(stream_typeRefDef))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_typeRefDef == NULL ? NULL : stream_typeRefDef->nextTree(stream_typeRefDef));

            	        	}
            	        	if ( stream_typeRefDef != NULL) stream_typeRefDef->reset(stream_typeRefDef);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto rulefuncSignatureEx; /* Prevent compiler warnings */
    rulefuncSignatureEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_44 != NULL) stream_44->free(stream_44);
        if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->free(stream_IDENTIFIER);
        if (stream_43 != NULL) stream_43->free(stream_43);
        if (stream_typeRefDef != NULL) stream_typeRefDef->free(stream_typeRefDef);
        if (stream_list_argDef != NULL) stream_list_argDef->free(stream_list_argDef);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end funcSignature */

/**
 * $ANTLR start list_argDef
 * MyGrammarTest.g:61:10: fragment list_argDef : ( argDef ( ',' argDef )* )? -> ^( ListArgDefs ( argDef )* ) ;
 */
static MyGrammarTestParser_list_argDef_return
list_argDef(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_list_argDef_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal33;
    MyGrammarTestParser_argDef_return argDef32;
    #undef	RETURN_TYPE_argDef32
    #define	RETURN_TYPE_argDef32 MyGrammarTestParser_argDef_return

    MyGrammarTestParser_argDef_return argDef34;
    #undef	RETURN_TYPE_argDef34
    #define	RETURN_TYPE_argDef34 MyGrammarTestParser_argDef_return

    pANTLR3_BASE_TREE char_literal33_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_48;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_argDef;
    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal33       = NULL;
    argDef32.tree = NULL;

    argDef34.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal33_tree   = NULL;

    stream_48   = NULL;
    #define CREATE_stream_48  if (stream_48 == NULL) {stream_48 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 48"); } 
    stream_argDef   = NULL;
    #define CREATE_stream_argDef  if (stream_argDef == NULL) {stream_argDef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule argDef"); }

    retval.tree  = NULL;

    {
        // MyGrammarTest.g:61:22: ( ( argDef ( ',' argDef )* )? -> ^( ListArgDefs ( argDef )* ) )
        // MyGrammarTest.g:61:24: ( argDef ( ',' argDef )* )?
        {
            // MyGrammarTest.g:61:24: ( argDef ( ',' argDef )* )?
            {
                int alt12=2;
                switch ( LA(1) )
                {
                    case IDENTIFIER:
                    	{
                    		alt12=1;
                    	}
                        break;
                }

                switch (alt12)
                {
            	case 1:
            	    // MyGrammarTest.g:61:25: argDef ( ',' argDef )*
            	    {
            	        FOLLOWPUSH(FOLLOW_argDef_in_list_argDef537);
            	        argDef32=argDef(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelist_argDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) { CREATE_stream_argDef; stream_argDef->add(stream_argDef, argDef32.tree, NULL); }

            	        // MyGrammarTest.g:61:32: ( ',' argDef )*

            	        for (;;)
            	        {
            	            int alt11=2;
            	            switch ( LA(1) )
            	            {
            	            case 48:
            	            	{
            	            		alt11=1;
            	            	}
            	                break;

            	            }

            	            switch (alt11)
            	            {
            	        	case 1:
            	        	    // MyGrammarTest.g:61:33: ',' argDef
            	        	    {
            	        	        char_literal33 = (pANTLR3_COMMON_TOKEN) MATCHT(48, &FOLLOW_48_in_list_argDef540);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelist_argDefEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_48; stream_48->add(stream_48, char_literal33, NULL); }


            	        	        FOLLOWPUSH(FOLLOW_argDef_in_list_argDef542);
            	        	        argDef34=argDef(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelist_argDefEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_argDef; stream_argDef->add(stream_argDef, argDef34.tree, NULL); }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop11;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop11: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            /* AST REWRITE
             * elements          : argDef
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 

            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 61:48: -> ^( ListArgDefs ( argDef )* )
            	{
            	    // MyGrammarTest.g:61:51: ^( ListArgDefs ( argDef )* )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ListArgDefs, (pANTLR3_UINT8)"ListArgDefs")
            	        , root_1));

            	        // MyGrammarTest.g:61:66: ( argDef )*
            	        {
            	        	while ( (stream_argDef != NULL && stream_argDef->hasNext(stream_argDef))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_argDef == NULL ? NULL : stream_argDef->nextTree(stream_argDef));

            	        	}
            	        	if (stream_argDef != NULL) stream_argDef->reset(stream_argDef);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto rulelist_argDefEx; /* Prevent compiler warnings */
    rulelist_argDefEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_48 != NULL) stream_48->free(stream_48);
        if (stream_argDef != NULL) stream_argDef->free(stream_argDef);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end list_argDef */

/**
 * $ANTLR start argDef
 * MyGrammarTest.g:62:10: fragment argDef : IDENTIFIER ( typeRefDef )? ;
 */
static MyGrammarTestParser_argDef_return
argDef(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_argDef_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER35;
    MyGrammarTestParser_typeRefDef_return typeRefDef36;
    #undef	RETURN_TYPE_typeRefDef36
    #define	RETURN_TYPE_typeRefDef36 MyGrammarTestParser_typeRefDef_return

    pANTLR3_BASE_TREE IDENTIFIER35_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    IDENTIFIER35       = NULL;
    typeRefDef36.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IDENTIFIER35_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:62:17: ( IDENTIFIER ( typeRefDef )? )
        // MyGrammarTest.g:62:19: IDENTIFIER ( typeRefDef )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            IDENTIFIER35 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_argDef572);
            if  (HASEXCEPTION())
            {
                goto ruleargDefEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            IDENTIFIER35_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER35));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER35_tree);
            }

            // MyGrammarTest.g:62:30: ( typeRefDef )?
            {
                int alt13=2;
                switch ( LA(1) )
                {
                    case 51:
                    	{
                    		alt13=1;
                    	}
                        break;
                }

                switch (alt13)
                {
            	case 1:
            	    // MyGrammarTest.g:62:30: typeRefDef
            	    {
            	        FOLLOWPUSH(FOLLOW_typeRefDef_in_argDef574);
            	        typeRefDef36=typeRefDef(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleargDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typeRefDef36.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleargDefEx; /* Prevent compiler warnings */
    ruleargDefEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end argDef */

/**
 * $ANTLR start typeRefDef
 * MyGrammarTest.g:63:10: fragment typeRefDef : ':' typeRef -> ^( TypeRef typeRef ) ;
 */
static MyGrammarTestParser_typeRefDef_return
typeRefDef(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_typeRefDef_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal37;
    MyGrammarTestParser_typeRef_return typeRef38;
    #undef	RETURN_TYPE_typeRef38
    #define	RETURN_TYPE_typeRef38 MyGrammarTestParser_typeRef_return

    pANTLR3_BASE_TREE char_literal37_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_51;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_typeRef;
    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal37       = NULL;
    typeRef38.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal37_tree   = NULL;

    stream_51   = NULL;
    #define CREATE_stream_51  if (stream_51 == NULL) {stream_51 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 51"); } 
    stream_typeRef   = NULL;
    #define CREATE_stream_typeRef  if (stream_typeRef == NULL) {stream_typeRef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule typeRef"); }

    retval.tree  = NULL;

    {
        // MyGrammarTest.g:63:21: ( ':' typeRef -> ^( TypeRef typeRef ) )
        // MyGrammarTest.g:63:23: ':' typeRef
        {
            char_literal37 = (pANTLR3_COMMON_TOKEN) MATCHT(51, &FOLLOW_51_in_typeRefDef585);
            if  (HASEXCEPTION())
            {
                goto ruletypeRefDefEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             
            if ( BACKTRACKING==0 ) { CREATE_stream_51; stream_51->add(stream_51, char_literal37, NULL); }


            FOLLOWPUSH(FOLLOW_typeRef_in_typeRefDef587);
            typeRef38=typeRef(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletypeRefDefEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) { CREATE_stream_typeRef; stream_typeRef->add(stream_typeRef, typeRef38.tree, NULL); }

            /* AST REWRITE
             * elements          : typeRef
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 

            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 63:35: -> ^( TypeRef typeRef )
            	{
            	    // MyGrammarTest.g:63:38: ^( TypeRef typeRef )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TypeRef, (pANTLR3_UINT8)"TypeRef")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_typeRef == NULL ? NULL : stream_typeRef->nextTree(stream_typeRef));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruletypeRefDefEx; /* Prevent compiler warnings */
    ruletypeRefDefEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_51 != NULL) stream_51->free(stream_51);
        if (stream_typeRef != NULL) stream_typeRef->free(stream_typeRef);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end typeRefDef */

/**
 * $ANTLR start statement
 * MyGrammarTest.g:68:1: statement : ( ifStatement | blockStatement | whileStatement | doStatement | breakStatement | expressionStatement ) ;
 */
static MyGrammarTestParser_statement_return
statement(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_statement_return retval;


    pANTLR3_BASE_TREE root_0;

    MyGrammarTestParser_ifStatement_return ifStatement39;
    #undef	RETURN_TYPE_ifStatement39
    #define	RETURN_TYPE_ifStatement39 MyGrammarTestParser_ifStatement_return

    MyGrammarTestParser_blockStatement_return blockStatement40;
    #undef	RETURN_TYPE_blockStatement40
    #define	RETURN_TYPE_blockStatement40 MyGrammarTestParser_blockStatement_return

    MyGrammarTestParser_whileStatement_return whileStatement41;
    #undef	RETURN_TYPE_whileStatement41
    #define	RETURN_TYPE_whileStatement41 MyGrammarTestParser_whileStatement_return

    MyGrammarTestParser_doStatement_return doStatement42;
    #undef	RETURN_TYPE_doStatement42
    #define	RETURN_TYPE_doStatement42 MyGrammarTestParser_doStatement_return

    MyGrammarTestParser_breakStatement_return breakStatement43;
    #undef	RETURN_TYPE_breakStatement43
    #define	RETURN_TYPE_breakStatement43 MyGrammarTestParser_breakStatement_return

    MyGrammarTestParser_expressionStatement_return expressionStatement44;
    #undef	RETURN_TYPE_expressionStatement44
    #define	RETURN_TYPE_expressionStatement44 MyGrammarTestParser_expressionStatement_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    ifStatement39.tree = NULL;

    blockStatement40.tree = NULL;

    whileStatement41.tree = NULL;

    doStatement42.tree = NULL;

    breakStatement43.tree = NULL;

    expressionStatement44.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // MyGrammarTest.g:68:11: ( ( ifStatement | blockStatement | whileStatement | doStatement | breakStatement | expressionStatement ) )
        // MyGrammarTest.g:68:13: ( ifStatement | blockStatement | whileStatement | doStatement | breakStatement | expressionStatement )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // MyGrammarTest.g:68:13: ( ifStatement | blockStatement | whileStatement | doStatement | breakStatement | expressionStatement )
            {
                int alt14=6;
                switch ( LA(1) )
                {
                case 65:
                	{
                		alt14=1;
                	}
                    break;
                case 57:
                	{
                		alt14=2;
                	}
                    break;
                case 77:
                	{
                		alt14=3;
                	}
                    break;
                case 70:
                	{
                		alt14=4;
                	}
                    break;
                case 59:
                	{
                		alt14=5;
                	}
                    break;
                case BITS_LITERAL:
                case BOOL_LITERAL:
                case CHAR:
                case DEC_LITERAL:
                case HEX_LITERAL:
                case IDENTIFIER:
                case STRING_LIT:
                case 41:
                case 43:
                case 49:
                	{
                		alt14=6;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return retval;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 14;
                    EXCEPTION->state        = 0;


                    goto rulestatementEx;

                }

                switch (alt14)
                {
            	case 1:
            	    // MyGrammarTest.g:68:15: ifStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_ifStatement_in_statement609);
            	        ifStatement39=ifStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, ifStatement39.tree);

            	    }
            	    break;
            	case 2:
            	    // MyGrammarTest.g:68:29: blockStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_blockStatement_in_statement613);
            	        blockStatement40=blockStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, blockStatement40.tree);

            	    }
            	    break;
            	case 3:
            	    // MyGrammarTest.g:68:46: whileStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_whileStatement_in_statement617);
            	        whileStatement41=whileStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, whileStatement41.tree);

            	    }
            	    break;
            	case 4:
            	    // MyGrammarTest.g:68:63: doStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_doStatement_in_statement621);
            	        doStatement42=doStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, doStatement42.tree);

            	    }
            	    break;
            	case 5:
            	    // MyGrammarTest.g:69:7: breakStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_breakStatement_in_statement629);
            	        breakStatement43=breakStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, breakStatement43.tree);

            	    }
            	    break;
            	case 6:
            	    // MyGrammarTest.g:69:24: expressionStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_expressionStatement_in_statement633);
            	        expressionStatement44=expressionStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expressionStatement44.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end statement */

/**
 * $ANTLR start ifStatement
 * MyGrammarTest.g:71:1: ifStatement : 'if' expr 'then' statement ( 'else' statement )? ;
 */
static MyGrammarTestParser_ifStatement_return
ifStatement(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_ifStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal45;
    pANTLR3_COMMON_TOKEN    string_literal47;
    pANTLR3_COMMON_TOKEN    string_literal49;
    MyGrammarTestParser_expr_return expr46;
    #undef	RETURN_TYPE_expr46
    #define	RETURN_TYPE_expr46 MyGrammarTestParser_expr_return

    MyGrammarTestParser_statement_return statement48;
    #undef	RETURN_TYPE_statement48
    #define	RETURN_TYPE_statement48 MyGrammarTestParser_statement_return

    MyGrammarTestParser_statement_return statement50;
    #undef	RETURN_TYPE_statement50
    #define	RETURN_TYPE_statement50 MyGrammarTestParser_statement_return

    pANTLR3_BASE_TREE string_literal45_tree;
    pANTLR3_BASE_TREE string_literal47_tree;
    pANTLR3_BASE_TREE string_literal49_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal45       = NULL;
    string_literal47       = NULL;
    string_literal49       = NULL;
    expr46.tree = NULL;

    statement48.tree = NULL;

    statement50.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal45_tree   = NULL;
    string_literal47_tree   = NULL;
    string_literal49_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:71:13: ( 'if' expr 'then' statement ( 'else' statement )? )
        // MyGrammarTest.g:71:15: 'if' expr 'then' statement ( 'else' statement )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            string_literal45 = (pANTLR3_COMMON_TOKEN) MATCHT(65, &FOLLOW_65_in_ifStatement644);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal45_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal45));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal45_tree);
            }

            FOLLOWPUSH(FOLLOW_expr_in_ifStatement646);
            expr46=expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expr46.tree);

            string_literal47 = (pANTLR3_COMMON_TOKEN) MATCHT(72, &FOLLOW_72_in_ifStatement648);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal47_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal47));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal47_tree);
            }

            FOLLOWPUSH(FOLLOW_statement_in_ifStatement650);
            statement48=statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, statement48.tree);

            // MyGrammarTest.g:71:42: ( 'else' statement )?
            {
                int alt15=2;
                switch ( LA(1) )
                {
                    case 63:
                    	{
                    		{
                    		    int LA15_1 = LA(2);
                    		    if ( (synpred27_MyGrammarTest(ctx)))
                    		    {
                    		        alt15=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt15)
                {
            	case 1:
            	    // MyGrammarTest.g:71:43: 'else' statement
            	    {
            	        string_literal49 = (pANTLR3_COMMON_TOKEN) MATCHT(63, &FOLLOW_63_in_ifStatement653);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        string_literal49_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal49));
            	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal49_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_statement_in_ifStatement655);
            	        statement50=statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, statement50.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleifStatementEx; /* Prevent compiler warnings */
    ruleifStatementEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end ifStatement */

/**
 * $ANTLR start blockStatement
 * MyGrammarTest.g:73:1: blockStatement : 'begin' ( statement )* 'end' ';' ;
 */
static MyGrammarTestParser_blockStatement_return
blockStatement(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_blockStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal51;
    pANTLR3_COMMON_TOKEN    string_literal53;
    pANTLR3_COMMON_TOKEN    char_literal54;
    MyGrammarTestParser_statement_return statement52;
    #undef	RETURN_TYPE_statement52
    #define	RETURN_TYPE_statement52 MyGrammarTestParser_statement_return

    pANTLR3_BASE_TREE string_literal51_tree;
    pANTLR3_BASE_TREE string_literal53_tree;
    pANTLR3_BASE_TREE char_literal54_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal51       = NULL;
    string_literal53       = NULL;
    char_literal54       = NULL;
    statement52.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal51_tree   = NULL;
    string_literal53_tree   = NULL;
    char_literal54_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:73:16: ( 'begin' ( statement )* 'end' ';' )
        // MyGrammarTest.g:73:18: 'begin' ( statement )* 'end' ';'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            string_literal51 = (pANTLR3_COMMON_TOKEN) MATCHT(57, &FOLLOW_57_in_blockStatement666);
            if  (HASEXCEPTION())
            {
                goto ruleblockStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal51_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal51));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal51_tree);
            }

            // MyGrammarTest.g:73:26: ( statement )*

            for (;;)
            {
                int alt16=2;
                switch ( LA(1) )
                {
                case BITS_LITERAL:
                case BOOL_LITERAL:
                case CHAR:
                case DEC_LITERAL:
                case HEX_LITERAL:
                case IDENTIFIER:
                case STRING_LIT:
                case 41:
                case 43:
                case 49:
                case 57:
                case 59:
                case 65:
                case 70:
                case 77:
                	{
                		alt16=1;
                	}
                    break;

                }

                switch (alt16)
                {
            	case 1:
            	    // MyGrammarTest.g:73:26: statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_blockStatement668);
            	        statement52=statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleblockStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, statement52.tree);

            	    }
            	    break;

            	default:
            	    goto loop16;	/* break out of the loop */
            	    break;
                }
            }
            loop16: ; /* Jump out to here if this rule does not match */


            string_literal53 = (pANTLR3_COMMON_TOKEN) MATCHT(64, &FOLLOW_64_in_blockStatement671);
            if  (HASEXCEPTION())
            {
                goto ruleblockStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal53_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal53));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal53_tree);
            }

            char_literal54 = (pANTLR3_COMMON_TOKEN) MATCHT(53, &FOLLOW_53_in_blockStatement673);
            if  (HASEXCEPTION())
            {
                goto ruleblockStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal54_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal54));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal54_tree);
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleblockStatementEx; /* Prevent compiler warnings */
    ruleblockStatementEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end blockStatement */

/**
 * $ANTLR start whileStatement
 * MyGrammarTest.g:75:1: whileStatement : 'while' expr 'do' statement ;
 */
static MyGrammarTestParser_whileStatement_return
whileStatement(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_whileStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal55;
    pANTLR3_COMMON_TOKEN    string_literal57;
    MyGrammarTestParser_expr_return expr56;
    #undef	RETURN_TYPE_expr56
    #define	RETURN_TYPE_expr56 MyGrammarTestParser_expr_return

    MyGrammarTestParser_statement_return statement58;
    #undef	RETURN_TYPE_statement58
    #define	RETURN_TYPE_statement58 MyGrammarTestParser_statement_return

    pANTLR3_BASE_TREE string_literal55_tree;
    pANTLR3_BASE_TREE string_literal57_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal55       = NULL;
    string_literal57       = NULL;
    expr56.tree = NULL;

    statement58.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal55_tree   = NULL;
    string_literal57_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:75:16: ( 'while' expr 'do' statement )
        // MyGrammarTest.g:75:18: 'while' expr 'do' statement
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            string_literal55 = (pANTLR3_COMMON_TOKEN) MATCHT(77, &FOLLOW_77_in_whileStatement682);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal55_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal55));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal55_tree);
            }

            FOLLOWPUSH(FOLLOW_expr_in_whileStatement684);
            expr56=expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expr56.tree);

            string_literal57 = (pANTLR3_COMMON_TOKEN) MATCHT(62, &FOLLOW_62_in_whileStatement686);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal57_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal57));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal57_tree);
            }

            FOLLOWPUSH(FOLLOW_statement_in_whileStatement688);
            statement58=statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, statement58.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulewhileStatementEx; /* Prevent compiler warnings */
    rulewhileStatementEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end whileStatement */

/**
 * $ANTLR start doStatement
 * MyGrammarTest.g:77:1: doStatement : 'repeat' statement ( 'while' | 'until' ) expr ';' ;
 */
static MyGrammarTestParser_doStatement_return
doStatement(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_doStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal59;
    pANTLR3_COMMON_TOKEN    set61;
    pANTLR3_COMMON_TOKEN    char_literal63;
    MyGrammarTestParser_statement_return statement60;
    #undef	RETURN_TYPE_statement60
    #define	RETURN_TYPE_statement60 MyGrammarTestParser_statement_return

    MyGrammarTestParser_expr_return expr62;
    #undef	RETURN_TYPE_expr62
    #define	RETURN_TYPE_expr62 MyGrammarTestParser_expr_return

    pANTLR3_BASE_TREE string_literal59_tree;
    pANTLR3_BASE_TREE set61_tree;
    pANTLR3_BASE_TREE char_literal63_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal59       = NULL;
    set61       = NULL;
    char_literal63       = NULL;
    statement60.tree = NULL;

    expr62.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal59_tree   = NULL;
    set61_tree   = NULL;
    char_literal63_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:77:13: ( 'repeat' statement ( 'while' | 'until' ) expr ';' )
        // MyGrammarTest.g:77:15: 'repeat' statement ( 'while' | 'until' ) expr ';'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            string_literal59 = (pANTLR3_COMMON_TOKEN) MATCHT(70, &FOLLOW_70_in_doStatement697);
            if  (HASEXCEPTION())
            {
                goto ruledoStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal59_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal59));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal59_tree);
            }

            FOLLOWPUSH(FOLLOW_statement_in_doStatement699);
            statement60=statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledoStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, statement60.tree);

            set61=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == 75 || LA(1) == 77 )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set61))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruledoStatementEx;
            }


            FOLLOWPUSH(FOLLOW_expr_in_doStatement707);
            expr62=expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledoStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expr62.tree);

            char_literal63 = (pANTLR3_COMMON_TOKEN) MATCHT(53, &FOLLOW_53_in_doStatement709);
            if  (HASEXCEPTION())
            {
                goto ruledoStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal63_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal63));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal63_tree);
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruledoStatementEx; /* Prevent compiler warnings */
    ruledoStatementEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end doStatement */

/**
 * $ANTLR start breakStatement
 * MyGrammarTest.g:79:1: breakStatement : 'break' ';' ;
 */
static MyGrammarTestParser_breakStatement_return
breakStatement(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_breakStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal64;
    pANTLR3_COMMON_TOKEN    char_literal65;

    pANTLR3_BASE_TREE string_literal64_tree;
    pANTLR3_BASE_TREE char_literal65_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal64       = NULL;
    char_literal65       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal64_tree   = NULL;
    char_literal65_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:79:16: ( 'break' ';' )
        // MyGrammarTest.g:79:18: 'break' ';'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            string_literal64 = (pANTLR3_COMMON_TOKEN) MATCHT(59, &FOLLOW_59_in_breakStatement718);
            if  (HASEXCEPTION())
            {
                goto rulebreakStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            string_literal64_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal64));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal64_tree);
            }

            char_literal65 = (pANTLR3_COMMON_TOKEN) MATCHT(53, &FOLLOW_53_in_breakStatement720);
            if  (HASEXCEPTION())
            {
                goto rulebreakStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal65_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal65));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal65_tree);
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulebreakStatementEx; /* Prevent compiler warnings */
    rulebreakStatementEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end breakStatement */

/**
 * $ANTLR start expressionStatement
 * MyGrammarTest.g:81:1: expressionStatement : expr ';' ;
 */
static MyGrammarTestParser_expressionStatement_return
expressionStatement(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_expressionStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal67;
    MyGrammarTestParser_expr_return expr66;
    #undef	RETURN_TYPE_expr66
    #define	RETURN_TYPE_expr66 MyGrammarTestParser_expr_return

    pANTLR3_BASE_TREE char_literal67_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal67       = NULL;
    expr66.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal67_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:81:21: ( expr ';' )
        // MyGrammarTest.g:81:23: expr ';'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_expr_in_expressionStatement729);
            expr66=expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpressionStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expr66.tree);

            char_literal67 = (pANTLR3_COMMON_TOKEN) MATCHT(53, &FOLLOW_53_in_expressionStatement731);
            if  (HASEXCEPTION())
            {
                goto ruleexpressionStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal67_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal67));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal67_tree);
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexpressionStatementEx; /* Prevent compiler warnings */
    ruleexpressionStatementEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end expressionStatement */

/**
 * $ANTLR start expr
 * MyGrammarTest.g:86:1: expr : assignExpr ;
 */
static MyGrammarTestParser_expr_return
expr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_expr_return retval;


    pANTLR3_BASE_TREE root_0;

    MyGrammarTestParser_assignExpr_return assignExpr68;
    #undef	RETURN_TYPE_assignExpr68
    #define	RETURN_TYPE_assignExpr68 MyGrammarTestParser_assignExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    assignExpr68.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // MyGrammarTest.g:86:6: ( assignExpr )
        // MyGrammarTest.g:86:8: assignExpr
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_assignExpr_in_expr743);
            assignExpr68=assignExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexprEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, assignExpr68.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexprEx; /* Prevent compiler warnings */
    ruleexprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end expr */

/**
 * $ANTLR start assignExpr
 * MyGrammarTest.g:88:10: fragment assignExpr : ( binaryExpr ( '+=' | ':=' ) binaryExpr | binaryExpr );
 */
static MyGrammarTestParser_assignExpr_return
assignExpr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_assignExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set70;
    MyGrammarTestParser_binaryExpr_return binaryExpr69;
    #undef	RETURN_TYPE_binaryExpr69
    #define	RETURN_TYPE_binaryExpr69 MyGrammarTestParser_binaryExpr_return

    MyGrammarTestParser_binaryExpr_return binaryExpr71;
    #undef	RETURN_TYPE_binaryExpr71
    #define	RETURN_TYPE_binaryExpr71 MyGrammarTestParser_binaryExpr_return

    MyGrammarTestParser_binaryExpr_return binaryExpr72;
    #undef	RETURN_TYPE_binaryExpr72
    #define	RETURN_TYPE_binaryExpr72 MyGrammarTestParser_binaryExpr_return

    pANTLR3_BASE_TREE set70_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set70       = NULL;
    binaryExpr69.tree = NULL;

    binaryExpr71.tree = NULL;

    binaryExpr72.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set70_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  MyGrammarTest.g:88:21: ( binaryExpr ( '+=' | ':=' ) binaryExpr | binaryExpr )

            ANTLR3_UINT32 alt17;

            alt17=2;

            switch ( LA(1) )
            {
            case 41:
            case 49:
            	{
            		{
            		    int LA17_1 = LA(2);
            		    if ( (synpred31_MyGrammarTest(ctx)))
            		    {
            		        alt17=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt17=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 17;
            		        EXCEPTION->state        = 1;


            		        goto ruleassignExprEx;

            		    }
            		}
            	}
                break;
            case BITS_LITERAL:
            case BOOL_LITERAL:
            case CHAR:
            case DEC_LITERAL:
            case HEX_LITERAL:
            case STRING_LIT:
            	{
            		{
            		    int LA17_2 = LA(2);
            		    if ( (synpred31_MyGrammarTest(ctx)))
            		    {
            		        alt17=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt17=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 17;
            		        EXCEPTION->state        = 2;


            		        goto ruleassignExprEx;

            		    }
            		}
            	}
                break;
            case IDENTIFIER:
            	{
            		{
            		    int LA17_3 = LA(2);
            		    if ( (synpred31_MyGrammarTest(ctx)))
            		    {
            		        alt17=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt17=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 17;
            		        EXCEPTION->state        = 3;


            		        goto ruleassignExprEx;

            		    }
            		}
            	}
                break;
            case 43:
            	{
            		{
            		    int LA17_4 = LA(2);
            		    if ( (synpred31_MyGrammarTest(ctx)))
            		    {
            		        alt17=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt17=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 17;
            		        EXCEPTION->state        = 4;


            		        goto ruleassignExprEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 17;
                EXCEPTION->state        = 0;


                goto ruleassignExprEx;

            }

            switch (alt17)
            {
        	case 1:
        	    // MyGrammarTest.g:88:23: binaryExpr ( '+=' | ':=' ) binaryExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_binaryExpr_in_assignExpr754);
        	        binaryExpr69=binaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, binaryExpr69.tree);

        	        set70=(pANTLR3_COMMON_TOKEN)LT(1);

        	        if ( LA(1) == 47 || LA(1) == 52 )
        	        {
        	            CONSUME();
        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
        	            (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set70))
        	            );
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	            FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return retval;
        	            }

        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = NULL;

        	            goto ruleassignExprEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_binaryExpr_in_assignExpr764);
        	        binaryExpr71=binaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, binaryExpr71.tree);

        	    }
        	    break;
        	case 2:
        	    // MyGrammarTest.g:88:62: binaryExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_binaryExpr_in_assignExpr769);
        	        binaryExpr72=binaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, binaryExpr72.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleassignExprEx; /* Prevent compiler warnings */
    ruleassignExprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end assignExpr */

/**
 * $ANTLR start binaryExpr
 * MyGrammarTest.g:90:10: fragment binaryExpr : additiveExpr ;
 */
static MyGrammarTestParser_binaryExpr_return
binaryExpr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_binaryExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    MyGrammarTestParser_additiveExpr_return additiveExpr73;
    #undef	RETURN_TYPE_additiveExpr73
    #define	RETURN_TYPE_additiveExpr73 MyGrammarTestParser_additiveExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    additiveExpr73.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // MyGrammarTest.g:90:21: ( additiveExpr )
        // MyGrammarTest.g:90:23: additiveExpr
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_additiveExpr_in_binaryExpr779);
            additiveExpr73=additiveExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebinaryExprEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, additiveExpr73.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulebinaryExprEx; /* Prevent compiler warnings */
    rulebinaryExprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end binaryExpr */

/**
 * $ANTLR start additiveExpr
 * MyGrammarTest.g:92:10: fragment additiveExpr : ( multiplicativeExpr ( '+' | '-' ) multiplicativeExpr | multiplicativeExpr );
 */
static MyGrammarTestParser_additiveExpr_return
additiveExpr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_additiveExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set75;
    MyGrammarTestParser_multiplicativeExpr_return multiplicativeExpr74;
    #undef	RETURN_TYPE_multiplicativeExpr74
    #define	RETURN_TYPE_multiplicativeExpr74 MyGrammarTestParser_multiplicativeExpr_return

    MyGrammarTestParser_multiplicativeExpr_return multiplicativeExpr76;
    #undef	RETURN_TYPE_multiplicativeExpr76
    #define	RETURN_TYPE_multiplicativeExpr76 MyGrammarTestParser_multiplicativeExpr_return

    MyGrammarTestParser_multiplicativeExpr_return multiplicativeExpr77;
    #undef	RETURN_TYPE_multiplicativeExpr77
    #define	RETURN_TYPE_multiplicativeExpr77 MyGrammarTestParser_multiplicativeExpr_return

    pANTLR3_BASE_TREE set75_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set75       = NULL;
    multiplicativeExpr74.tree = NULL;

    multiplicativeExpr76.tree = NULL;

    multiplicativeExpr77.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set75_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  MyGrammarTest.g:92:23: ( multiplicativeExpr ( '+' | '-' ) multiplicativeExpr | multiplicativeExpr )

            ANTLR3_UINT32 alt18;

            alt18=2;

            switch ( LA(1) )
            {
            case 41:
            case 49:
            	{
            		{
            		    int LA18_1 = LA(2);
            		    if ( (synpred33_MyGrammarTest(ctx)))
            		    {
            		        alt18=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt18=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 18;
            		        EXCEPTION->state        = 1;


            		        goto ruleadditiveExprEx;

            		    }
            		}
            	}
                break;
            case BITS_LITERAL:
            case BOOL_LITERAL:
            case CHAR:
            case DEC_LITERAL:
            case HEX_LITERAL:
            case STRING_LIT:
            	{
            		{
            		    int LA18_2 = LA(2);
            		    if ( (synpred33_MyGrammarTest(ctx)))
            		    {
            		        alt18=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt18=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 18;
            		        EXCEPTION->state        = 2;


            		        goto ruleadditiveExprEx;

            		    }
            		}
            	}
                break;
            case IDENTIFIER:
            	{
            		{
            		    int LA18_3 = LA(2);
            		    if ( (synpred33_MyGrammarTest(ctx)))
            		    {
            		        alt18=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt18=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 18;
            		        EXCEPTION->state        = 3;


            		        goto ruleadditiveExprEx;

            		    }
            		}
            	}
                break;
            case 43:
            	{
            		{
            		    int LA18_4 = LA(2);
            		    if ( (synpred33_MyGrammarTest(ctx)))
            		    {
            		        alt18=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt18=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 18;
            		        EXCEPTION->state        = 4;


            		        goto ruleadditiveExprEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 18;
                EXCEPTION->state        = 0;


                goto ruleadditiveExprEx;

            }

            switch (alt18)
            {
        	case 1:
        	    // MyGrammarTest.g:92:25: multiplicativeExpr ( '+' | '-' ) multiplicativeExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_multiplicativeExpr_in_additiveExpr790);
        	        multiplicativeExpr74=multiplicativeExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleadditiveExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, multiplicativeExpr74.tree);

        	        set75=(pANTLR3_COMMON_TOKEN)LT(1);

        	        if ( LA(1) == 46 || LA(1) == 49 )
        	        {
        	            CONSUME();
        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
        	            (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set75))
        	            );
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	            FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return retval;
        	            }

        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = NULL;

        	            goto ruleadditiveExprEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_multiplicativeExpr_in_additiveExpr800);
        	        multiplicativeExpr76=multiplicativeExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleadditiveExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, multiplicativeExpr76.tree);

        	    }
        	    break;
        	case 2:
        	    // MyGrammarTest.g:92:78: multiplicativeExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_multiplicativeExpr_in_additiveExpr805);
        	        multiplicativeExpr77=multiplicativeExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleadditiveExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, multiplicativeExpr77.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleadditiveExprEx; /* Prevent compiler warnings */
    ruleadditiveExprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end additiveExpr */

/**
 * $ANTLR start multiplicativeExpr
 * MyGrammarTest.g:94:10: fragment multiplicativeExpr : ( unaryExpr ( '*' | '/' | '%' ) unaryExpr | unaryExpr );
 */
static MyGrammarTestParser_multiplicativeExpr_return
multiplicativeExpr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_multiplicativeExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set79;
    MyGrammarTestParser_unaryExpr_return unaryExpr78;
    #undef	RETURN_TYPE_unaryExpr78
    #define	RETURN_TYPE_unaryExpr78 MyGrammarTestParser_unaryExpr_return

    MyGrammarTestParser_unaryExpr_return unaryExpr80;
    #undef	RETURN_TYPE_unaryExpr80
    #define	RETURN_TYPE_unaryExpr80 MyGrammarTestParser_unaryExpr_return

    MyGrammarTestParser_unaryExpr_return unaryExpr81;
    #undef	RETURN_TYPE_unaryExpr81
    #define	RETURN_TYPE_unaryExpr81 MyGrammarTestParser_unaryExpr_return

    pANTLR3_BASE_TREE set79_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set79       = NULL;
    unaryExpr78.tree = NULL;

    unaryExpr80.tree = NULL;

    unaryExpr81.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set79_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  MyGrammarTest.g:94:29: ( unaryExpr ( '*' | '/' | '%' ) unaryExpr | unaryExpr )

            ANTLR3_UINT32 alt19;

            alt19=2;

            switch ( LA(1) )
            {
            case 41:
            case 49:
            	{
            		{
            		    int LA19_1 = LA(2);
            		    if ( (synpred36_MyGrammarTest(ctx)))
            		    {
            		        alt19=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt19=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 19;
            		        EXCEPTION->state        = 1;


            		        goto rulemultiplicativeExprEx;

            		    }
            		}
            	}
                break;
            case BITS_LITERAL:
            case BOOL_LITERAL:
            case CHAR:
            case DEC_LITERAL:
            case HEX_LITERAL:
            case STRING_LIT:
            	{
            		{
            		    int LA19_2 = LA(2);
            		    if ( (synpred36_MyGrammarTest(ctx)))
            		    {
            		        alt19=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt19=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 19;
            		        EXCEPTION->state        = 2;


            		        goto rulemultiplicativeExprEx;

            		    }
            		}
            	}
                break;
            case IDENTIFIER:
            	{
            		{
            		    int LA19_3 = LA(2);
            		    if ( (synpred36_MyGrammarTest(ctx)))
            		    {
            		        alt19=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt19=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 19;
            		        EXCEPTION->state        = 3;


            		        goto rulemultiplicativeExprEx;

            		    }
            		}
            	}
                break;
            case 43:
            	{
            		{
            		    int LA19_4 = LA(2);
            		    if ( (synpred36_MyGrammarTest(ctx)))
            		    {
            		        alt19=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt19=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 19;
            		        EXCEPTION->state        = 4;


            		        goto rulemultiplicativeExprEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 19;
                EXCEPTION->state        = 0;


                goto rulemultiplicativeExprEx;

            }

            switch (alt19)
            {
        	case 1:
        	    // MyGrammarTest.g:94:31: unaryExpr ( '*' | '/' | '%' ) unaryExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_unaryExpr_in_multiplicativeExpr816);
        	        unaryExpr78=unaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemultiplicativeExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, unaryExpr78.tree);

        	        set79=(pANTLR3_COMMON_TOKEN)LT(1);

        	        if ( LA(1) == 42 || LA(1) == 45 || LA(1) == 50 )
        	        {
        	            CONSUME();
        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
        	            (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set79))
        	            );
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	            FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return retval;
        	            }

        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = NULL;

        	            goto rulemultiplicativeExprEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_unaryExpr_in_multiplicativeExpr830);
        	        unaryExpr80=unaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemultiplicativeExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, unaryExpr80.tree);

        	    }
        	    break;
        	case 2:
        	    // MyGrammarTest.g:94:71: unaryExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_unaryExpr_in_multiplicativeExpr834);
        	        unaryExpr81=unaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemultiplicativeExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, unaryExpr81.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulemultiplicativeExprEx; /* Prevent compiler warnings */
    rulemultiplicativeExprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end multiplicativeExpr */

/**
 * $ANTLR start unaryExpr
 * MyGrammarTest.g:96:10: fragment unaryExpr : ( unOp unaryExpr | primaryExpr );
 */
static MyGrammarTestParser_unaryExpr_return
unaryExpr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_unaryExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    MyGrammarTestParser_unOp_return unOp82;
    #undef	RETURN_TYPE_unOp82
    #define	RETURN_TYPE_unOp82 MyGrammarTestParser_unOp_return

    MyGrammarTestParser_unaryExpr_return unaryExpr83;
    #undef	RETURN_TYPE_unaryExpr83
    #define	RETURN_TYPE_unaryExpr83 MyGrammarTestParser_unaryExpr_return

    MyGrammarTestParser_primaryExpr_return primaryExpr84;
    #undef	RETURN_TYPE_primaryExpr84
    #define	RETURN_TYPE_primaryExpr84 MyGrammarTestParser_primaryExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    unOp82.tree = NULL;

    unaryExpr83.tree = NULL;

    primaryExpr84.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  MyGrammarTest.g:96:20: ( unOp unaryExpr | primaryExpr )

            ANTLR3_UINT32 alt20;

            alt20=2;

            switch ( LA(1) )
            {
            case 41:
            case 49:
            	{
            		alt20=1;
            	}
                break;
            case BITS_LITERAL:
            case BOOL_LITERAL:
            case CHAR:
            case DEC_LITERAL:
            case HEX_LITERAL:
            case IDENTIFIER:
            case STRING_LIT:
            case 43:
            	{
            		alt20=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 20;
                EXCEPTION->state        = 0;


                goto ruleunaryExprEx;

            }

            switch (alt20)
            {
        	case 1:
        	    // MyGrammarTest.g:96:22: unOp unaryExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_unOp_in_unaryExpr845);
        	        unOp82=unOp(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, unOp82.tree);

        	        FOLLOWPUSH(FOLLOW_unaryExpr_in_unaryExpr847);
        	        unaryExpr83=unaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, unaryExpr83.tree);

        	    }
        	    break;
        	case 2:
        	    // MyGrammarTest.g:96:39: primaryExpr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_primaryExpr_in_unaryExpr851);
        	        primaryExpr84=primaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, primaryExpr84.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleunaryExprEx; /* Prevent compiler warnings */
    ruleunaryExprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end unaryExpr */

/**
 * $ANTLR start primaryExpr
 * MyGrammarTest.g:98:10: fragment primaryExpr : ( literal | IDENTIFIER | '(' expr ')' | call | indexer );
 */
static MyGrammarTestParser_primaryExpr_return
primaryExpr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_primaryExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER86;
    pANTLR3_COMMON_TOKEN    char_literal87;
    pANTLR3_COMMON_TOKEN    char_literal89;
    MyGrammarTestParser_literal_return literal85;
    #undef	RETURN_TYPE_literal85
    #define	RETURN_TYPE_literal85 MyGrammarTestParser_literal_return

    MyGrammarTestParser_expr_return expr88;
    #undef	RETURN_TYPE_expr88
    #define	RETURN_TYPE_expr88 MyGrammarTestParser_expr_return

    MyGrammarTestParser_call_return call90;
    #undef	RETURN_TYPE_call90
    #define	RETURN_TYPE_call90 MyGrammarTestParser_call_return

    MyGrammarTestParser_indexer_return indexer91;
    #undef	RETURN_TYPE_indexer91
    #define	RETURN_TYPE_indexer91 MyGrammarTestParser_indexer_return

    pANTLR3_BASE_TREE IDENTIFIER86_tree;
    pANTLR3_BASE_TREE char_literal87_tree;
    pANTLR3_BASE_TREE char_literal89_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    IDENTIFIER86       = NULL;
    char_literal87       = NULL;
    char_literal89       = NULL;
    literal85.tree = NULL;

    expr88.tree = NULL;

    call90.tree = NULL;

    indexer91.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IDENTIFIER86_tree   = NULL;
    char_literal87_tree   = NULL;
    char_literal89_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  MyGrammarTest.g:99:5: ( literal | IDENTIFIER | '(' expr ')' | call | indexer )

            ANTLR3_UINT32 alt21;

            alt21=5;

            switch ( LA(1) )
            {
            case BITS_LITERAL:
            case BOOL_LITERAL:
            case CHAR:
            case DEC_LITERAL:
            case HEX_LITERAL:
            case STRING_LIT:
            	{
            		alt21=1;
            	}
                break;
            case IDENTIFIER:
            	{
            		switch ( LA(2) )
            		{
            		case 43:
            			{
            				alt21=4;
            			}
            		    break;
            		case 54:
            			{
            				alt21=5;
            			}
            		    break;
            		case EOF:
            		case 42:
            		case 44:
            		case 45:
            		case 46:
            		case 47:
            		case 48:
            		case 49:
            		case 50:
            		case 52:
            		case 53:
            		case 55:
            		case 62:
            		case 72:
            			{
            				alt21=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return retval;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 21;
            		    EXCEPTION->state        = 2;


            		    goto ruleprimaryExprEx;

            		}

            	}
                break;
            case 43:
            	{
            		alt21=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 21;
                EXCEPTION->state        = 0;


                goto ruleprimaryExprEx;

            }

            switch (alt21)
            {
        	case 1:
        	    // MyGrammarTest.g:99:7: literal
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_literal_in_primaryExpr866);
        	        literal85=literal(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, literal85.tree);

        	    }
        	    break;
        	case 2:
        	    // MyGrammarTest.g:100:7: IDENTIFIER
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        IDENTIFIER86 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_primaryExpr902);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) {
        	        IDENTIFIER86_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER86));
        	        ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER86_tree);
        	        }

        	    }
        	    break;
        	case 3:
        	    // MyGrammarTest.g:101:7: '(' expr ')'
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        char_literal87 = (pANTLR3_COMMON_TOKEN) MATCHT(43, &FOLLOW_43_in_primaryExpr935);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) {
        	        char_literal87_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal87));
        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal87_tree);
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_primaryExpr937);
        	        expr88=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expr88.tree);

        	        char_literal89 = (pANTLR3_COMMON_TOKEN) MATCHT(44, &FOLLOW_44_in_primaryExpr939);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) {
        	        char_literal89_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal89));
        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal89_tree);
        	        }

        	    }
        	    break;
        	case 4:
        	    // MyGrammarTest.g:102:7: call
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_call_in_primaryExpr971);
        	        call90=call(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, call90.tree);

        	    }
        	    break;
        	case 5:
        	    // MyGrammarTest.g:103:7: indexer
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_indexer_in_primaryExpr1010);
        	        indexer91=indexer(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, indexer91.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleprimaryExprEx; /* Prevent compiler warnings */
    ruleprimaryExprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end primaryExpr */

/**
 * $ANTLR start call
 * MyGrammarTest.g:106:1: call : IDENTIFIER '(' list_expr ')' ;
 */
static MyGrammarTestParser_call_return
call(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_call_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER92;
    pANTLR3_COMMON_TOKEN    char_literal93;
    pANTLR3_COMMON_TOKEN    char_literal95;
    MyGrammarTestParser_list_expr_return list_expr94;
    #undef	RETURN_TYPE_list_expr94
    #define	RETURN_TYPE_list_expr94 MyGrammarTestParser_list_expr_return

    pANTLR3_BASE_TREE IDENTIFIER92_tree;
    pANTLR3_BASE_TREE char_literal93_tree;
    pANTLR3_BASE_TREE char_literal95_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    IDENTIFIER92       = NULL;
    char_literal93       = NULL;
    char_literal95       = NULL;
    list_expr94.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IDENTIFIER92_tree   = NULL;
    char_literal93_tree   = NULL;
    char_literal95_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:106:6: ( IDENTIFIER '(' list_expr ')' )
        // MyGrammarTest.g:106:8: IDENTIFIER '(' list_expr ')'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            IDENTIFIER92 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_call1051);
            if  (HASEXCEPTION())
            {
                goto rulecallEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            IDENTIFIER92_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER92));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER92_tree);
            }

            char_literal93 = (pANTLR3_COMMON_TOKEN) MATCHT(43, &FOLLOW_43_in_call1053);
            if  (HASEXCEPTION())
            {
                goto rulecallEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal93_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal93));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal93_tree);
            }

            FOLLOWPUSH(FOLLOW_list_expr_in_call1055);
            list_expr94=list_expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecallEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, list_expr94.tree);

            char_literal95 = (pANTLR3_COMMON_TOKEN) MATCHT(44, &FOLLOW_44_in_call1057);
            if  (HASEXCEPTION())
            {
                goto rulecallEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal95_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal95));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal95_tree);
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulecallEx; /* Prevent compiler warnings */
    rulecallEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end call */

/**
 * $ANTLR start indexer
 * MyGrammarTest.g:108:10: fragment indexer : IDENTIFIER '[' list_expr ']' ;
 */
static MyGrammarTestParser_indexer_return
indexer(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_indexer_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER96;
    pANTLR3_COMMON_TOKEN    char_literal97;
    pANTLR3_COMMON_TOKEN    char_literal99;
    MyGrammarTestParser_list_expr_return list_expr98;
    #undef	RETURN_TYPE_list_expr98
    #define	RETURN_TYPE_list_expr98 MyGrammarTestParser_list_expr_return

    pANTLR3_BASE_TREE IDENTIFIER96_tree;
    pANTLR3_BASE_TREE char_literal97_tree;
    pANTLR3_BASE_TREE char_literal99_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    IDENTIFIER96       = NULL;
    char_literal97       = NULL;
    char_literal99       = NULL;
    list_expr98.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IDENTIFIER96_tree   = NULL;
    char_literal97_tree   = NULL;
    char_literal99_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:108:18: ( IDENTIFIER '[' list_expr ']' )
        // MyGrammarTest.g:108:20: IDENTIFIER '[' list_expr ']'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            IDENTIFIER96 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_indexer1068);
            if  (HASEXCEPTION())
            {
                goto ruleindexerEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            IDENTIFIER96_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER96));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER96_tree);
            }

            char_literal97 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_indexer1070);
            if  (HASEXCEPTION())
            {
                goto ruleindexerEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal97_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal97));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal97_tree);
            }

            FOLLOWPUSH(FOLLOW_list_expr_in_indexer1072);
            list_expr98=list_expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleindexerEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, list_expr98.tree);

            char_literal99 = (pANTLR3_COMMON_TOKEN) MATCHT(55, &FOLLOW_55_in_indexer1074);
            if  (HASEXCEPTION())
            {
                goto ruleindexerEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal99_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal99));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal99_tree);
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleindexerEx; /* Prevent compiler warnings */
    ruleindexerEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end indexer */

/**
 * $ANTLR start literal
 * MyGrammarTest.g:110:10: fragment literal : ( BOOL_LITERAL | STRING_LIT | CHAR | HEX_LITERAL | BITS_LITERAL | DEC_LITERAL );
 */
static MyGrammarTestParser_literal_return
literal(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_literal_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set100;

    pANTLR3_BASE_TREE set100_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set100       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set100_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:110:18: ( BOOL_LITERAL | STRING_LIT | CHAR | HEX_LITERAL | BITS_LITERAL | DEC_LITERAL )
        // MyGrammarTest.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set100=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == BITS_LITERAL || LA(1) == BOOL_LITERAL || LA(1) == CHAR || LA(1) == DEC_LITERAL || LA(1) == HEX_LITERAL || LA(1) == STRING_LIT )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set100))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleliteralEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleliteralEx; /* Prevent compiler warnings */
    ruleliteralEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end literal */

/**
 * $ANTLR start list_expr
 * MyGrammarTest.g:112:1: list_expr : ( expr ( ',' expr )* )? ;
 */
static MyGrammarTestParser_list_expr_return
list_expr(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_list_expr_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal102;
    MyGrammarTestParser_expr_return expr101;
    #undef	RETURN_TYPE_expr101
    #define	RETURN_TYPE_expr101 MyGrammarTestParser_expr_return

    MyGrammarTestParser_expr_return expr103;
    #undef	RETURN_TYPE_expr103
    #define	RETURN_TYPE_expr103 MyGrammarTestParser_expr_return

    pANTLR3_BASE_TREE char_literal102_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal102       = NULL;
    expr101.tree = NULL;

    expr103.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal102_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:112:11: ( ( expr ( ',' expr )* )? )
        // MyGrammarTest.g:112:13: ( expr ( ',' expr )* )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // MyGrammarTest.g:112:13: ( expr ( ',' expr )* )?
            {
                int alt23=2;
                switch ( LA(1) )
                {
                    case BITS_LITERAL:
                    case BOOL_LITERAL:
                    case CHAR:
                    case DEC_LITERAL:
                    case HEX_LITERAL:
                    case IDENTIFIER:
                    case STRING_LIT:
                    case 41:
                    case 43:
                    case 49:
                    	{
                    		alt23=1;
                    	}
                        break;
                }

                switch (alt23)
                {
            	case 1:
            	    // MyGrammarTest.g:112:14: expr ( ',' expr )*
            	    {
            	        FOLLOWPUSH(FOLLOW_expr_in_list_expr1115);
            	        expr101=expr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelist_exprEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expr101.tree);

            	        // MyGrammarTest.g:112:19: ( ',' expr )*

            	        for (;;)
            	        {
            	            int alt22=2;
            	            switch ( LA(1) )
            	            {
            	            case 48:
            	            	{
            	            		alt22=1;
            	            	}
            	                break;

            	            }

            	            switch (alt22)
            	            {
            	        	case 1:
            	        	    // MyGrammarTest.g:112:20: ',' expr
            	        	    {
            	        	        char_literal102 = (pANTLR3_COMMON_TOKEN) MATCHT(48, &FOLLOW_48_in_list_expr1118);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelist_exprEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) {
            	        	        char_literal102_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal102));
            	        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal102_tree);
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_expr_in_list_expr1120);
            	        	        expr103=expr(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelist_exprEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, expr103.tree);

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop22;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop22: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulelist_exprEx; /* Prevent compiler warnings */
    rulelist_exprEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end list_expr */

/**
 * $ANTLR start unOp
 * MyGrammarTest.g:114:1: unOp : ( '-' | '!' ) ;
 */
static MyGrammarTestParser_unOp_return
unOp(pMyGrammarTestParser ctx)
{
    MyGrammarTestParser_unOp_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set104;

    pANTLR3_BASE_TREE set104_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set104       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set104_tree   = NULL;


    retval.tree  = NULL;

    {
        // MyGrammarTest.g:114:6: ( ( '-' | '!' ) )
        // MyGrammarTest.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set104=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == 41 || LA(1) == 49 )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set104))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleunOpEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleunOpEx; /* Prevent compiler warnings */
    ruleunOpEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end unOp */

// $ANTLR start synpred27_MyGrammarTest
static void synpred27_MyGrammarTest_fragment(pMyGrammarTestParser ctx )
{
    // MyGrammarTest.g:71:43: ( 'else' statement )
    // MyGrammarTest.g:71:43: 'else' statement
    {
         MATCHT(63, &FOLLOW_63_in_synpred27_MyGrammarTest653);
        if  (HASEXCEPTION())
        {
            goto rulesynpred27_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        FOLLOWPUSH(FOLLOW_statement_in_synpred27_MyGrammarTest655);
        statement(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred27_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred27_MyGrammarTestEx; /* Prevent compiler warnings */
rulesynpred27_MyGrammarTestEx: ;

}
// $ANTLR end synpred27_MyGrammarTest

// $ANTLR start synpred31_MyGrammarTest
static void synpred31_MyGrammarTest_fragment(pMyGrammarTestParser ctx )
{
    // MyGrammarTest.g:88:23: ( binaryExpr ( '+=' | ':=' ) binaryExpr )
    // MyGrammarTest.g:88:23: binaryExpr ( '+=' | ':=' ) binaryExpr
    {
        FOLLOWPUSH(FOLLOW_binaryExpr_in_synpred31_MyGrammarTest754);
        binaryExpr(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred31_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        if ( LA(1) == 47 || LA(1) == 52 )
        {
            CONSUME();
            PERRORRECOVERY=ANTLR3_FALSE;
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            EXCEPTION->expectingSet = NULL;

            goto rulesynpred31_MyGrammarTestEx;
        }


        FOLLOWPUSH(FOLLOW_binaryExpr_in_synpred31_MyGrammarTest764);
        binaryExpr(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred31_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred31_MyGrammarTestEx; /* Prevent compiler warnings */
rulesynpred31_MyGrammarTestEx: ;

}
// $ANTLR end synpred31_MyGrammarTest

// $ANTLR start synpred33_MyGrammarTest
static void synpred33_MyGrammarTest_fragment(pMyGrammarTestParser ctx )
{
    // MyGrammarTest.g:92:25: ( multiplicativeExpr ( '+' | '-' ) multiplicativeExpr )
    // MyGrammarTest.g:92:25: multiplicativeExpr ( '+' | '-' ) multiplicativeExpr
    {
        FOLLOWPUSH(FOLLOW_multiplicativeExpr_in_synpred33_MyGrammarTest790);
        multiplicativeExpr(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred33_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        if ( LA(1) == 46 || LA(1) == 49 )
        {
            CONSUME();
            PERRORRECOVERY=ANTLR3_FALSE;
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            EXCEPTION->expectingSet = NULL;

            goto rulesynpred33_MyGrammarTestEx;
        }


        FOLLOWPUSH(FOLLOW_multiplicativeExpr_in_synpred33_MyGrammarTest800);
        multiplicativeExpr(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred33_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred33_MyGrammarTestEx; /* Prevent compiler warnings */
rulesynpred33_MyGrammarTestEx: ;

}
// $ANTLR end synpred33_MyGrammarTest

// $ANTLR start synpred36_MyGrammarTest
static void synpred36_MyGrammarTest_fragment(pMyGrammarTestParser ctx )
{
    // MyGrammarTest.g:94:31: ( unaryExpr ( '*' | '/' | '%' ) unaryExpr )
    // MyGrammarTest.g:94:31: unaryExpr ( '*' | '/' | '%' ) unaryExpr
    {
        FOLLOWPUSH(FOLLOW_unaryExpr_in_synpred36_MyGrammarTest816);
        unaryExpr(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred36_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        if ( LA(1) == 42 || LA(1) == 45 || LA(1) == 50 )
        {
            CONSUME();
            PERRORRECOVERY=ANTLR3_FALSE;
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            EXCEPTION->expectingSet = NULL;

            goto rulesynpred36_MyGrammarTestEx;
        }


        FOLLOWPUSH(FOLLOW_unaryExpr_in_synpred36_MyGrammarTest830);
        unaryExpr(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred36_MyGrammarTestEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred36_MyGrammarTestEx; /* Prevent compiler warnings */
rulesynpred36_MyGrammarTestEx: ;

}
// $ANTLR end synpred36_MyGrammarTest
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred31_MyGrammarTest(pMyGrammarTestParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred31_MyGrammarTest_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred36_MyGrammarTest(pMyGrammarTestParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred36_MyGrammarTest_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred27_MyGrammarTest(pMyGrammarTestParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred27_MyGrammarTest_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred33_MyGrammarTest(pMyGrammarTestParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred33_MyGrammarTest_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
